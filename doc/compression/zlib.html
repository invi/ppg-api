<!DOCTYPE html><html lang="en"><head><title>compression/zlib</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="compression/zlib"><meta name="groc-project-path" content="lib/compression/zlib.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">lib/compression/zlib.js</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="cm">/*</span>
<span class="cm"> * $Id: rawdeflate.js,v 0.3 2009/03/01 19:05:05 dankogai Exp dankogai $</span>
<span class="cm"> *</span>
<span class="cm"> * Original:</span>
<span class="cm"> *   http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt</span>
<span class="cm"> */</span>
 </div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Zlib lib by djazz</p></div></div><div class="code"><div class="wrapper"> 
<span class="kd">var</span> <span class="nx">Zlib</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="nx">Zlib</span> <span class="cm">/* Name for debugging */</span> <span class="p">()</span> <span class="p">{</span>

<span class="kd">var</span> <span class="nx">Deflate</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

<span class="cm">/* Copyright (C) 1999 Masanao Izumo &lt;iz@onicos.co.jp&gt;</span>
<span class="cm"> * Version: 1.0.1</span>
<span class="cm"> * LastModified: Dec 25 1999</span>
<span class="cm"> */</span>

<span class="cm">/* constant parameters */</span>
<span class="kd">var</span> <span class="nx">zip_WSIZE</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>    <span class="c1">// Sliding Window size</span>
<span class="kd">var</span> <span class="nx">zip_STORED_BLOCK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_STATIC_TREES</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_DYN_TREES</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="cm">/* for deflate */</span>
<span class="kd">var</span> <span class="nx">zip_DEFAULT_LEVEL</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_FULL_SEARCH</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_INBUFSIZ</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span> <span class="c1">// Input buffer size</span>
<span class="kd">var</span> <span class="nx">zip_INBUF_EXTRA</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span> <span class="c1">// Extra buffer</span>
<span class="kd">var</span> <span class="nx">zip_OUTBUFSIZ</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_window_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">zip_WSIZE</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_MIN_MATCH</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_MAX_MATCH</span> <span class="o">=</span> <span class="mi">258</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_BITS</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>for SMALL_MEM</p></div></div><div class="code"><div class="wrapper"><span class="kd">var</span> <span class="nx">zip_LIT_BUFSIZE</span> <span class="o">=</span> <span class="mh">0x2000</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_HASH_BITS</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>for MEDIUM<em>MEM
var zip</em>LIT<em>BUFSIZE = 0x4000;
var zip</em>HASH<em>BITS = 14;
for BIG</em>MEM
var zip<em>LIT</em>BUFSIZE = 0x8000;
var zip<em>HASH</em>BITS = 15;</p></div></div><div class="code"><div class="wrapper"><span class="k">if</span><span class="p">(</span><span class="nx">zip_LIT_BUFSIZE</span> <span class="o">&gt;</span> <span class="nx">zip_INBUFSIZ</span><span class="p">)</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;error: zip_INBUFSIZ is too small&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="p">((</span><span class="nx">zip_WSIZE</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">zip_BITS</span><span class="p">))</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;error: zip_WSIZE is too large&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="nx">zip_HASH_BITS</span> <span class="o">&gt;</span> <span class="nx">zip_BITS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;error: zip_HASH_BITS is too large&quot;</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="nx">zip_HASH_BITS</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">||</span> <span class="nx">zip_MAX_MATCH</span> <span class="o">!=</span> <span class="mi">258</span><span class="p">)</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;error: Code too clever&quot;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">zip_DIST_BUFSIZE</span> <span class="o">=</span> <span class="nx">zip_LIT_BUFSIZE</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_HASH_SIZE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">zip_HASH_BITS</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_HASH_MASK</span> <span class="o">=</span> <span class="nx">zip_HASH_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_WMASK</span> <span class="o">=</span> <span class="nx">zip_WSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_NIL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Tail of hash chains</span>
<span class="kd">var</span> <span class="nx">zip_TOO_FAR</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_MIN_LOOKAHEAD</span> <span class="o">=</span> <span class="nx">zip_MAX_MATCH</span> <span class="o">+</span> <span class="nx">zip_MIN_MATCH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_MAX_DIST</span> <span class="o">=</span> <span class="nx">zip_WSIZE</span> <span class="o">-</span> <span class="nx">zip_MIN_LOOKAHEAD</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_SMALLEST</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_MAX_BITS</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_MAX_BL_BITS</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_LENGTH_CODES</span> <span class="o">=</span> <span class="mi">29</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_LITERALS</span> <span class="o">=</span><span class="mi">256</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_END_BLOCK</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_L_CODES</span> <span class="o">=</span> <span class="nx">zip_LITERALS</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">zip_LENGTH_CODES</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_D_CODES</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_BL_CODES</span> <span class="o">=</span> <span class="mi">19</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_REP_3_6</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_REPZ_3_10</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_REPZ_11_138</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_HEAP_SIZE</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">zip_L_CODES</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_H_SHIFT</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">((</span><span class="nx">zip_HASH_BITS</span> <span class="o">+</span> <span class="nx">zip_MIN_MATCH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
         <span class="nx">zip_MIN_MATCH</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

<span class="cm">/* variables */</span>
<span class="kd">var</span> <span class="nx">zip_free_queue</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_qhead</span><span class="p">,</span> <span class="nx">zip_qtail</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_initflag</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_outbuf</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_outcnt</span><span class="p">,</span> <span class="nx">zip_outoff</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_complete</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_window</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_d_buf</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_l_buf</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_prev</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_bi_buf</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_bi_valid</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_block_start</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_ins_h</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_hash_head</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_prev_match</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_match_available</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_match_length</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_prev_length</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_strstart</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_match_start</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_eofile</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_lookahead</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_max_chain_length</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_max_lazy_match</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_compr_level</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_good_match</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_nice_match</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_dyn_ltree</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_dyn_dtree</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_static_ltree</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_static_dtree</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_bl_tree</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_l_desc</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_d_desc</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_bl_desc</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_bl_count</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_heap</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_heap_len</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_heap_max</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_depth</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_length_code</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_dist_code</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_base_length</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_base_dist</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_flag_buf</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_last_lit</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_last_dist</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_last_flags</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_flags</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_flag_bit</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_opt_len</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_static_len</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_deflate_data</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_deflate_pos</span><span class="p">;</span>

<span class="cm">/* objects (deflate) */</span>

<span class="kd">var</span> <span class="nx">zip_DeflateCT</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">fc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// frequency count or bit string</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">dl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// father node in Huffman tree or length of bit string</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_DeflateTreeDesc</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">dyn_tree</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// the dynamic tree</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">static_tree</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>  <span class="c1">// corresponding static tree or NULL</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">extra_bits</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// extra bits for each code or NULL</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">extra_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// base index for extra_bits</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">elems</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// max number of elements in the tree</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">max_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// max bit length for the codes</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">max_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// largest code with non zero frequency</span>
<span class="p">}</span>

<span class="cm">/* Values for max_lazy_match, good_match and max_chain_length, depending on</span>
<span class="cm"> * the desired pack level (0..9). The values given below have been tuned to</span>
<span class="cm"> * exclude worst case performance for pathological files. Better values may be</span>
<span class="cm"> * found for specific files.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_DeflateConfiguration</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">good_length</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// reduce lazy search above this match length</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">max_lazy</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span>    <span class="c1">// do not perform lazy search above this match length</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">nice_length</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span> <span class="c1">// quit search above this match length</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">max_chain</span> <span class="o">=</span> <span class="nx">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_DeflateBuffer</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_OUTBUFSIZ</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* constant tables */</span>
<span class="kd">var</span> <span class="nx">zip_extra_lbits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">zip_extra_dbits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">13</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">zip_extra_blbits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">zip_bl_order</span> <span class="o">=</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">zip_configuration_table</span> <span class="o">=</span> <span class="p">[</span>
  <span class="k">new</span> <span class="nx">zip_DeflateConfiguration</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">zip_DeflateConfiguration</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span>    <span class="mi">4</span><span class="p">,</span>   <span class="mi">8</span><span class="p">,</span>    <span class="mi">4</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">zip_DeflateConfiguration</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span>    <span class="mi">5</span><span class="p">,</span>  <span class="mi">16</span><span class="p">,</span>    <span class="mi">8</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">zip_DeflateConfiguration</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span>    <span class="mi">6</span><span class="p">,</span>  <span class="mi">32</span><span class="p">,</span>   <span class="mi">32</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">zip_DeflateConfiguration</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span>    <span class="mi">4</span><span class="p">,</span>  <span class="mi">16</span><span class="p">,</span>   <span class="mi">16</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">zip_DeflateConfiguration</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span>   <span class="mi">16</span><span class="p">,</span>  <span class="mi">32</span><span class="p">,</span>   <span class="mi">32</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">zip_DeflateConfiguration</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span>   <span class="mi">16</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span>  <span class="mi">128</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">zip_DeflateConfiguration</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span>   <span class="mi">32</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span>  <span class="mi">256</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">zip_DeflateConfiguration</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">258</span><span class="p">,</span> <span class="mi">1024</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">zip_DeflateConfiguration</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">258</span><span class="p">,</span> <span class="mi">258</span><span class="p">,</span> <span class="mi">4096</span><span class="p">)];</span>


<span class="cm">/* routines (deflate) */</span>

<span class="kd">var</span> <span class="nx">zip_deflate_start</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">level</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">level</span><span class="p">)</span>
  <span class="nx">level</span> <span class="o">=</span> <span class="nx">zip_DEFAULT_LEVEL</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">level</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
  <span class="nx">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">level</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">)</span>
  <span class="nx">level</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

    <span class="nx">zip_compr_level</span> <span class="o">=</span> <span class="nx">level</span><span class="p">;</span>
    <span class="nx">zip_initflag</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="nx">zip_eofile</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_outbuf</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
  <span class="k">return</span><span class="p">;</span>

    <span class="nx">zip_free_queue</span> <span class="o">=</span> <span class="nx">zip_qhead</span> <span class="o">=</span> <span class="nx">zip_qtail</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_outbuf</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_OUTBUFSIZ</span><span class="p">);</span>
    <span class="nx">zip_window</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_window_size</span><span class="p">);</span>
    <span class="nx">zip_d_buf</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_DIST_BUFSIZE</span><span class="p">);</span>
    <span class="nx">zip_l_buf</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_INBUFSIZ</span> <span class="o">+</span> <span class="nx">zip_INBUF_EXTRA</span><span class="p">);</span>
    <span class="nx">zip_prev</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">zip_BITS</span><span class="p">);</span>
    <span class="nx">zip_dyn_ltree</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_HEAP_SIZE</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">zip_HEAP_SIZE</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
  <span class="nx">zip_dyn_ltree</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_DeflateCT</span><span class="p">();</span>
    <span class="nx">zip_dyn_dtree</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nx">zip_D_CODES</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="nx">zip_D_CODES</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
  <span class="nx">zip_dyn_dtree</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_DeflateCT</span><span class="p">();</span>
    <span class="nx">zip_static_ltree</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_L_CODES</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">zip_L_CODES</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
  <span class="nx">zip_static_ltree</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_DeflateCT</span><span class="p">();</span>
    <span class="nx">zip_static_dtree</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_D_CODES</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">zip_D_CODES</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
  <span class="nx">zip_static_dtree</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_DeflateCT</span><span class="p">();</span>
    <span class="nx">zip_bl_tree</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nx">zip_BL_CODES</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="nx">zip_BL_CODES</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
  <span class="nx">zip_bl_tree</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_DeflateCT</span><span class="p">();</span>
    <span class="nx">zip_l_desc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_DeflateTreeDesc</span><span class="p">();</span>
    <span class="nx">zip_d_desc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_DeflateTreeDesc</span><span class="p">();</span>
    <span class="nx">zip_bl_desc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_DeflateTreeDesc</span><span class="p">();</span>
    <span class="nx">zip_bl_count</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_MAX_BITS</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="nx">zip_heap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nx">zip_L_CODES</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="nx">zip_depth</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nx">zip_L_CODES</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="nx">zip_length_code</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_MAX_MATCH</span><span class="o">-</span><span class="nx">zip_MIN_MATCH</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="nx">zip_dist_code</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">512</span><span class="p">);</span>
    <span class="nx">zip_base_length</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_LENGTH_CODES</span><span class="p">);</span>
    <span class="nx">zip_base_dist</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_D_CODES</span><span class="p">);</span>
    <span class="nx">zip_flag_buf</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">zip_LIT_BUFSIZE</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_deflate_end</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">zip_free_queue</span> <span class="o">=</span> <span class="nx">zip_qhead</span> <span class="o">=</span> <span class="nx">zip_qtail</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_outbuf</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_window</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_d_buf</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_l_buf</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_prev</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_dyn_ltree</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_dyn_dtree</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_static_ltree</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_static_dtree</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_bl_tree</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_l_desc</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_d_desc</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_bl_desc</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_bl_count</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_heap</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_depth</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_length_code</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_dist_code</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_base_length</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_base_dist</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_flag_buf</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_reuse_queue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">zip_free_queue</span><span class="p">;</span>
    <span class="nx">zip_free_queue</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_new_queue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">p</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">zip_free_queue</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
    <span class="p">{</span>
  <span class="nx">p</span> <span class="o">=</span> <span class="nx">zip_free_queue</span><span class="p">;</span>
  <span class="nx">zip_free_queue</span> <span class="o">=</span> <span class="nx">zip_free_queue</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
  <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_DeflateBuffer</span><span class="p">();</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">len</span> <span class="o">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">return</span> <span class="nx">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_head1</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">zip_prev</span><span class="p">[</span><span class="nx">zip_WSIZE</span> <span class="o">+</span> <span class="nx">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_head2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">zip_prev</span><span class="p">[</span><span class="nx">zip_WSIZE</span> <span class="o">+</span> <span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* put_byte is used for the compressed output, put_ubyte for the</span>
<span class="cm"> * uncompressed output. However unlzw() uses window for its</span>
<span class="cm"> * suffix table instead of its output buffer, so it does not use put_ubyte</span>
<span class="cm"> * (to be cleaned up).</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_put_byte</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">zip_outbuf</span><span class="p">[</span><span class="nx">zip_outoff</span> <span class="o">+</span> <span class="nx">zip_outcnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_outoff</span> <span class="o">+</span> <span class="nx">zip_outcnt</span> <span class="o">==</span> <span class="nx">zip_OUTBUFSIZ</span><span class="p">)</span>
  <span class="nx">zip_qoutbuf</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* Output a 16 bit value, lsb first */</span>
<span class="kd">var</span> <span class="nx">zip_put_short</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">w</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_outoff</span> <span class="o">+</span> <span class="nx">zip_outcnt</span> <span class="o">&lt;</span> <span class="nx">zip_OUTBUFSIZ</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_outbuf</span><span class="p">[</span><span class="nx">zip_outoff</span> <span class="o">+</span> <span class="nx">zip_outcnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">w</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
  <span class="nx">zip_outbuf</span><span class="p">[</span><span class="nx">zip_outoff</span> <span class="o">+</span> <span class="nx">zip_outcnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">w</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">zip_put_byte</span><span class="p">(</span><span class="nx">w</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
  <span class="nx">zip_put_byte</span><span class="p">(</span><span class="nx">w</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Insert string s in the dictionary and set match_head to the previous head</span>
<span class="cm"> * of the hash chain (the most recent string with same hash key). Return</span>
<span class="cm"> * the previous length of the hash chain.</span>
<span class="cm"> * IN  assertion: all calls to to INSERT_STRING are made with consecutive</span>
<span class="cm"> *    input characters and the first MIN_MATCH bytes of s are valid</span>
<span class="cm"> *    (except for the last MIN_MATCH-1 bytes of the input file).</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_INSERT_STRING</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">zip_ins_h</span> <span class="o">=</span> <span class="p">((</span><span class="nx">zip_ins_h</span> <span class="o">&lt;&lt;</span> <span class="nx">zip_H_SHIFT</span><span class="p">)</span>
     <span class="o">^</span> <span class="p">(</span><span class="nx">zip_window</span><span class="p">[</span><span class="nx">zip_strstart</span> <span class="o">+</span> <span class="nx">zip_MIN_MATCH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span>
  <span class="o">&amp;</span> <span class="nx">zip_HASH_MASK</span><span class="p">;</span>
    <span class="nx">zip_hash_head</span> <span class="o">=</span> <span class="nx">zip_head1</span><span class="p">(</span><span class="nx">zip_ins_h</span><span class="p">);</span>
    <span class="nx">zip_prev</span><span class="p">[</span><span class="nx">zip_strstart</span> <span class="o">&amp;</span> <span class="nx">zip_WMASK</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_hash_head</span><span class="p">;</span>
    <span class="nx">zip_head2</span><span class="p">(</span><span class="nx">zip_ins_h</span><span class="p">,</span> <span class="nx">zip_strstart</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Send a code of the given tree. c and tree must not have side effects */</span>
<span class="kd">var</span> <span class="nx">zip_SEND_CODE</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">tree</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">zip_send_bits</span><span class="p">(</span><span class="nx">tree</span><span class="p">[</span><span class="nx">c</span><span class="p">].</span><span class="nx">fc</span><span class="p">,</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">c</span><span class="p">].</span><span class="nx">dl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Mapping from a distance to a distance code. dist is the distance - 1 and</span>
<span class="cm"> * must not have side effects. dist_code[256] and dist_code[257] are never</span>
<span class="cm"> * used.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_D_CODE</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">dist</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">dist</span> <span class="o">&lt;</span> <span class="mi">256</span> <span class="o">?</span> <span class="nx">zip_dist_code</span><span class="p">[</span><span class="nx">dist</span><span class="p">]</span>
      <span class="o">:</span> <span class="nx">zip_dist_code</span><span class="p">[</span><span class="mi">256</span> <span class="o">+</span> <span class="p">(</span><span class="nx">dist</span><span class="o">&gt;&gt;</span><span class="mi">7</span><span class="p">)])</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Compares to subtrees, using the tree depth as tie breaker when</span>
<span class="cm"> * the subtrees have equal frequency. This minimizes the worst case length.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_SMALLER</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">fc</span> <span class="o">&lt;</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">m</span><span class="p">].</span><span class="nx">fc</span> <span class="o">||</span>
      <span class="p">(</span><span class="nx">tree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">fc</span> <span class="o">==</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">m</span><span class="p">].</span><span class="nx">fc</span> <span class="o">&amp;&amp;</span> <span class="nx">zip_depth</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">zip_depth</span><span class="p">[</span><span class="nx">m</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * &lt;STRIKE&gt;read string data&lt;/STRIKE&gt;</span>
<span class="cm"> * read arraybuffer data</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_read_buff</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">offset</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">zip_deflate_data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="nx">zip_deflate_pos</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">+=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">buff</span><span class="p">[</span><span class="nx">offset</span> <span class="o">+</span> <span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_deflate_data</span><span class="p">[</span><span class="nx">zip_deflate_pos</span><span class="o">++</span><span class="p">];</span>
  <span class="p">}</span>
    <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Initialize the &quot;longest match&quot; routines for a new file</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_lm_init</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">j</span><span class="p">;</span>

    <span class="cm">/* Initialize the hash table. */</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">zip_HASH_SIZE</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>zip<em>head2(j, zip</em>NIL);</p></div></div><div class="code"><div class="wrapper">  <span class="nx">zip_prev</span><span class="p">[</span><span class="nx">zip_WSIZE</span> <span class="o">+</span> <span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cm">/* prev will be initialized on the fly */</span>

    <span class="cm">/* Set the default configuration parameters:</span>
<span class="cm">     */</span>
    <span class="nx">zip_max_lazy_match</span> <span class="o">=</span> <span class="nx">zip_configuration_table</span><span class="p">[</span><span class="nx">zip_compr_level</span><span class="p">].</span><span class="nx">max_lazy</span><span class="p">;</span>
    <span class="nx">zip_good_match</span>     <span class="o">=</span> <span class="nx">zip_configuration_table</span><span class="p">[</span><span class="nx">zip_compr_level</span><span class="p">].</span><span class="nx">good_length</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">zip_FULL_SEARCH</span><span class="p">)</span>
  <span class="nx">zip_nice_match</span> <span class="o">=</span> <span class="nx">zip_configuration_table</span><span class="p">[</span><span class="nx">zip_compr_level</span><span class="p">].</span><span class="nx">nice_length</span><span class="p">;</span>
    <span class="nx">zip_max_chain_length</span> <span class="o">=</span> <span class="nx">zip_configuration_table</span><span class="p">[</span><span class="nx">zip_compr_level</span><span class="p">].</span><span class="nx">max_chain</span><span class="p">;</span>

    <span class="nx">zip_strstart</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_block_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="nx">zip_lookahead</span> <span class="o">=</span> <span class="nx">zip_read_buff</span><span class="p">(</span><span class="nx">zip_window</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">zip_WSIZE</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_lookahead</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_eofile</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="nx">zip_lookahead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">zip_eofile</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="cm">/* Make sure that we always have enough lookahead. This is important</span>
<span class="cm">     * if input comes from a device such as a tty.</span>
<span class="cm">     */</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">zip_lookahead</span> <span class="o">&lt;</span> <span class="nx">zip_MIN_LOOKAHEAD</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">zip_eofile</span><span class="p">)</span>
  <span class="nx">zip_fill_window</span><span class="p">();</span>

    <span class="cm">/* If lookahead &lt; MIN_MATCH, ins_h is garbage, but this is</span>
<span class="cm">     * not important since only literal bytes will be emitted.</span>
<span class="cm">     */</span>
    <span class="nx">zip_ins_h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">zip_MIN_MATCH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><pre><code> UPDATE_HASH(ins_h, window[j]);
</code></pre></div></div><div class="code"><div class="wrapper">  <span class="nx">zip_ins_h</span> <span class="o">=</span> <span class="p">((</span><span class="nx">zip_ins_h</span> <span class="o">&lt;&lt;</span> <span class="nx">zip_H_SHIFT</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="nx">zip_window</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span> <span class="o">&amp;</span> <span class="nx">zip_HASH_MASK</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Set match_start to the longest match starting at the given string and</span>
<span class="cm"> * return its length. Matches shorter or equal to prev_length are discarded,</span>
<span class="cm"> * in which case the result is equal to prev_length and match_start is</span>
<span class="cm"> * garbage.</span>
<span class="cm"> * IN assertions: cur_match is the head of the hash chain for the current</span>
<span class="cm"> *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_longest_match</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">cur_match</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">chain_length</span> <span class="o">=</span> <span class="nx">zip_max_chain_length</span><span class="p">;</span> <span class="c1">// max hash chain length</span>
    <span class="kd">var</span> <span class="nx">scanp</span> <span class="o">=</span> <span class="nx">zip_strstart</span><span class="p">;</span> <span class="c1">// current string</span>
    <span class="kd">var</span> <span class="nx">matchp</span><span class="p">;</span>   <span class="c1">// matched string</span>
    <span class="kd">var</span> <span class="nx">len</span><span class="p">;</span>    <span class="c1">// length of current match</span>
    <span class="kd">var</span> <span class="nx">best_len</span> <span class="o">=</span> <span class="nx">zip_prev_length</span><span class="p">;</span> <span class="c1">// best match length so far</span>

    <span class="cm">/* Stop when cur_match becomes &lt;= limit. To simplify the code,</span>
<span class="cm">     * we prevent matches with the string of window index 0.</span>
<span class="cm">     */</span>
    <span class="kd">var</span> <span class="nx">limit</span> <span class="o">=</span> <span class="p">(</span><span class="nx">zip_strstart</span> <span class="o">&gt;</span> <span class="nx">zip_MAX_DIST</span> <span class="o">?</span> <span class="nx">zip_strstart</span> <span class="o">-</span> <span class="nx">zip_MAX_DIST</span> <span class="o">:</span> <span class="nx">zip_NIL</span><span class="p">);</span>

    <span class="kd">var</span> <span class="nx">strendp</span> <span class="o">=</span> <span class="nx">zip_strstart</span> <span class="o">+</span> <span class="nx">zip_MAX_MATCH</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">scan_end1</span> <span class="o">=</span> <span class="nx">zip_window</span><span class="p">[</span><span class="nx">scanp</span> <span class="o">+</span> <span class="nx">best_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">scan_end</span>  <span class="o">=</span> <span class="nx">zip_window</span><span class="p">[</span><span class="nx">scanp</span> <span class="o">+</span> <span class="nx">best_len</span><span class="p">];</span>

    <span class="cm">/* Do not waste too much time if we already have a good match: */</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_prev_length</span> <span class="o">&gt;=</span> <span class="nx">zip_good_match</span><span class="p">)</span>
  <span class="nx">chain_length</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Assert(encoder->strstart &lt;= window<em>size-MIN</em>LOOKAHEAD, "insufficient lookahead");</p></div></div><div class="code"><div class="wrapper">    <span class="k">do</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Assert(cur_match &lt; encoder->strstart, "no future");</p></div></div><div class="code"><div class="wrapper">  <span class="nx">matchp</span> <span class="o">=</span> <span class="nx">cur_match</span><span class="p">;</span>

  <span class="cm">/* Skip to next match if the match length cannot increase</span>
<span class="cm">      * or if the match length is less than 2:</span>
<span class="cm">  */</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">zip_window</span><span class="p">[</span><span class="nx">matchp</span> <span class="o">+</span> <span class="nx">best_len</span><span class="p">]</span>  <span class="o">!=</span> <span class="nx">scan_end</span>  <span class="o">||</span>
     <span class="nx">zip_window</span><span class="p">[</span><span class="nx">matchp</span> <span class="o">+</span> <span class="nx">best_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="o">!=</span> <span class="nx">scan_end1</span> <span class="o">||</span>
     <span class="nx">zip_window</span><span class="p">[</span><span class="nx">matchp</span><span class="p">]</span>     <span class="o">!=</span> <span class="nx">zip_window</span><span class="p">[</span><span class="nx">scanp</span><span class="p">]</span> <span class="o">||</span>
     <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">matchp</span><span class="p">]</span>     <span class="o">!=</span> <span class="nx">zip_window</span><span class="p">[</span><span class="nx">scanp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* The check at best_len-1 can be removed because it will be made</span>
<span class="cm">         * again later. (This heuristic is not always a win.)</span>
<span class="cm">         * It is not necessary to compare scan[2] and match[2] since they</span>
<span class="cm">         * are always equal when the other bytes match, given that</span>
<span class="cm">         * the hash keys are equal and that HASH_BITS &gt;= 8.</span>
<span class="cm">         */</span>
  <span class="nx">scanp</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="nx">matchp</span><span class="o">++</span><span class="p">;</span>

  <span class="cm">/* We check for insufficient lookahead only every 8th comparison;</span>
<span class="cm">         * the 256th check will be made at strstart+258.</span>
<span class="cm">         */</span>
  <span class="k">do</span> <span class="p">{</span>
  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">scanp</span><span class="p">]</span> <span class="o">==</span> <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">matchp</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
    <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">scanp</span><span class="p">]</span> <span class="o">==</span> <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">matchp</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
    <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">scanp</span><span class="p">]</span> <span class="o">==</span> <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">matchp</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
    <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">scanp</span><span class="p">]</span> <span class="o">==</span> <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">matchp</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
    <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">scanp</span><span class="p">]</span> <span class="o">==</span> <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">matchp</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
    <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">scanp</span><span class="p">]</span> <span class="o">==</span> <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">matchp</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
    <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">scanp</span><span class="p">]</span> <span class="o">==</span> <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">matchp</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
    <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">scanp</span><span class="p">]</span> <span class="o">==</span> <span class="nx">zip_window</span><span class="p">[</span><span class="o">++</span><span class="nx">matchp</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
    <span class="nx">scanp</span> <span class="o">&lt;</span> <span class="nx">strendp</span><span class="p">);</span>

      <span class="nx">len</span> <span class="o">=</span> <span class="nx">zip_MAX_MATCH</span> <span class="o">-</span> <span class="p">(</span><span class="nx">strendp</span> <span class="o">-</span> <span class="nx">scanp</span><span class="p">);</span>
      <span class="nx">scanp</span> <span class="o">=</span> <span class="nx">strendp</span> <span class="o">-</span> <span class="nx">zip_MAX_MATCH</span><span class="p">;</span>

      <span class="k">if</span><span class="p">(</span><span class="nx">len</span> <span class="o">&gt;</span> <span class="nx">best_len</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">zip_match_start</span> <span class="o">=</span> <span class="nx">cur_match</span><span class="p">;</span>
    <span class="nx">best_len</span> <span class="o">=</span> <span class="nx">len</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_FULL_SEARCH</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">len</span> <span class="o">&gt;=</span> <span class="nx">zip_MAX_MATCH</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">len</span> <span class="o">&gt;=</span> <span class="nx">zip_nice_match</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">scan_end1</span>  <span class="o">=</span> <span class="nx">zip_window</span><span class="p">[</span><span class="nx">scanp</span> <span class="o">+</span> <span class="nx">best_len</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="nx">scan_end</span>   <span class="o">=</span> <span class="nx">zip_window</span><span class="p">[</span><span class="nx">scanp</span> <span class="o">+</span> <span class="nx">best_len</span><span class="p">];</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">((</span><span class="nx">cur_match</span> <span class="o">=</span> <span class="nx">zip_prev</span><span class="p">[</span><span class="nx">cur_match</span> <span class="o">&amp;</span> <span class="nx">zip_WMASK</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nx">limit</span>
      <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="nx">chain_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">best_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Fill the window when the lookahead becomes insufficient.</span>
<span class="cm"> * Updates strstart and lookahead, and sets eofile if end of input file.</span>
<span class="cm"> * IN assertion: lookahead &lt; MIN_LOOKAHEAD &amp;&amp; strstart + lookahead &gt; 0</span>
<span class="cm"> * OUT assertions: at least one byte has been read, or eofile is set;</span>
<span class="cm"> *    file reads are performed for at least two bytes (required for the</span>
<span class="cm"> *    translate_eol option).</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_fill_window</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Amount of free space at the end of the window.</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">more</span> <span class="o">=</span> <span class="nx">zip_window_size</span> <span class="o">-</span> <span class="nx">zip_lookahead</span> <span class="o">-</span> <span class="nx">zip_strstart</span><span class="p">;</span>

    <span class="cm">/* If the window is almost full and there is insufficient lookahead,</span>
<span class="cm">     * move the upper half to the lower one to make room in the upper half.</span>
<span class="cm">     */</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">more</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Very unlikely, but possible on 16 bit machine if strstart == 0</span>
<span class="cm">         * and lookahead == 1 (input done one byte at time)</span>
<span class="cm">         */</span>
  <span class="nx">more</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">zip_strstart</span> <span class="o">&gt;=</span> <span class="nx">zip_WSIZE</span> <span class="o">+</span> <span class="nx">zip_MAX_DIST</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* By the IN assertion, the window is not empty so we can&#39;t confuse</span>
<span class="cm">         * more == 0 with more == 64K on a 16 bit machine.</span>
<span class="cm">         */</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Assert(window<em>size == (ulg)2*WSIZE, "no sliding with BIG</em>MEM");</p></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>System.arraycopy(window, WSIZE, window, 0, WSIZE);</p></div></div><div class="code"><div class="wrapper">  <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">zip_WSIZE</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">zip_window</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_window</span><span class="p">[</span><span class="nx">n</span> <span class="o">+</span> <span class="nx">zip_WSIZE</span><span class="p">];</span>
      
  <span class="nx">zip_match_start</span> <span class="o">-=</span> <span class="nx">zip_WSIZE</span><span class="p">;</span>
  <span class="nx">zip_strstart</span>    <span class="o">-=</span> <span class="nx">zip_WSIZE</span><span class="p">;</span> <span class="cm">/* we now have strstart &gt;= MAX_DIST: */</span>
  <span class="nx">zip_block_start</span> <span class="o">-=</span> <span class="nx">zip_WSIZE</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">zip_HASH_SIZE</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">m</span> <span class="o">=</span> <span class="nx">zip_head1</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
      <span class="nx">zip_head2</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span> <span class="o">&gt;=</span> <span class="nx">zip_WSIZE</span> <span class="o">?</span> <span class="nx">m</span> <span class="o">-</span> <span class="nx">zip_WSIZE</span> <span class="o">:</span> <span class="nx">zip_NIL</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">zip_WSIZE</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* If n is not on any hash chain, prev[n] is garbage but</span>
<span class="cm">       * its value will never be used.</span>
<span class="cm">       */</span>
      <span class="nx">m</span> <span class="o">=</span> <span class="nx">zip_prev</span><span class="p">[</span><span class="nx">n</span><span class="p">];</span>
      <span class="nx">zip_prev</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">m</span> <span class="o">&gt;=</span> <span class="nx">zip_WSIZE</span> <span class="o">?</span> <span class="nx">m</span> <span class="o">-</span> <span class="nx">zip_WSIZE</span> <span class="o">:</span> <span class="nx">zip_NIL</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">more</span> <span class="o">+=</span> <span class="nx">zip_WSIZE</span><span class="p">;</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>At this point, more >= 2</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">zip_eofile</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">=</span> <span class="nx">zip_read_buff</span><span class="p">(</span><span class="nx">zip_window</span><span class="p">,</span> <span class="nx">zip_strstart</span> <span class="o">+</span> <span class="nx">zip_lookahead</span><span class="p">,</span> <span class="nx">more</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nx">zip_eofile</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="k">else</span>
      <span class="nx">zip_lookahead</span> <span class="o">+=</span> <span class="nx">n</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Processes a new input file and return its compressed length. This</span>
<span class="cm"> * function does not perform lazy evaluationof matches and inserts</span>
<span class="cm"> * new strings in the dictionary only for unmatched strings or for short</span>
<span class="cm"> * matches. It is used only for the fast compression options.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_deflate_fast</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">zip_lookahead</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">zip_qhead</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">flush</span><span class="p">;</span> <span class="c1">// set if current block must be flushed</span>

  <span class="cm">/* Insert the string window[strstart .. strstart+2] in the</span>
<span class="cm">   * dictionary, and set hash_head to the head of the hash chain:</span>
<span class="cm">   */</span>
  <span class="nx">zip_INSERT_STRING</span><span class="p">();</span>

  <span class="cm">/* Find the longest match, discarding those &lt;= prev_length.</span>
<span class="cm">   * At this point we have always match_length &lt; MIN_MATCH</span>
<span class="cm">   */</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">zip_hash_head</span> <span class="o">!=</span> <span class="nx">zip_NIL</span> <span class="o">&amp;&amp;</span>
     <span class="nx">zip_strstart</span> <span class="o">-</span> <span class="nx">zip_hash_head</span> <span class="o">&lt;=</span> <span class="nx">zip_MAX_DIST</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* To simplify the code, we prevent matches with the string</span>
<span class="cm">       * of window index 0 (in particular we have to avoid a match</span>
<span class="cm">       * of the string with itself at the start of the input file).</span>
<span class="cm">       */</span>
      <span class="nx">zip_match_length</span> <span class="o">=</span> <span class="nx">zip_longest_match</span><span class="p">(</span><span class="nx">zip_hash_head</span><span class="p">);</span>
      <span class="cm">/* longest_match() sets match_start */</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">zip_match_length</span> <span class="o">&gt;</span> <span class="nx">zip_lookahead</span><span class="p">)</span>
    <span class="nx">zip_match_length</span> <span class="o">=</span> <span class="nx">zip_lookahead</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">zip_match_length</span> <span class="o">&gt;=</span> <span class="nx">zip_MIN_MATCH</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><pre><code>check_match(strstart, match_start, match_length);
</code></pre></div></div><div class="code"><div class="wrapper">      <span class="nx">flush</span> <span class="o">=</span> <span class="nx">zip_ct_tally</span><span class="p">(</span><span class="nx">zip_strstart</span> <span class="o">-</span> <span class="nx">zip_match_start</span><span class="p">,</span>
         <span class="nx">zip_match_length</span> <span class="o">-</span> <span class="nx">zip_MIN_MATCH</span><span class="p">);</span>
      <span class="nx">zip_lookahead</span> <span class="o">-=</span> <span class="nx">zip_match_length</span><span class="p">;</span>

      <span class="cm">/* Insert new strings in the hash table only if the match length</span>
<span class="cm">       * is not too large. This saves time but degrades compression.</span>
<span class="cm">       */</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">zip_match_length</span> <span class="o">&lt;=</span> <span class="nx">zip_max_lazy_match</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">zip_match_length</span><span class="o">--</span><span class="p">;</span> <span class="c1">// string at strstart already in hash table</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="nx">zip_strstart</span><span class="o">++</span><span class="p">;</span>
        <span class="nx">zip_INSERT_STRING</span><span class="p">();</span>
        <span class="cm">/* strstart never exceeds WSIZE-MAX_MATCH, so there are</span>
<span class="cm">         * always MIN_MATCH bytes ahead. If lookahead &lt; MIN_MATCH</span>
<span class="cm">         * these bytes are garbage, but it does not matter since</span>
<span class="cm">         * the next lookahead bytes will be emitted as literals.</span>
<span class="cm">         */</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="nx">zip_match_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="nx">zip_strstart</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">zip_strstart</span> <span class="o">+=</span> <span class="nx">zip_match_length</span><span class="p">;</span>
    <span class="nx">zip_match_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_ins_h</span> <span class="o">=</span> <span class="nx">zip_window</span><span class="p">[</span><span class="nx">zip_strstart</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><pre><code>UPDATE_HASH(ins_h, window[strstart + 1]);
</code></pre></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_ins_h</span> <span class="o">=</span> <span class="p">((</span><span class="nx">zip_ins_h</span><span class="o">&lt;&lt;</span><span class="nx">zip_H_SHIFT</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="nx">zip_window</span><span class="p">[</span><span class="nx">zip_strstart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span> <span class="o">&amp;</span> <span class="nx">zip_HASH_MASK</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><h1 id="if-min-match--3">if MIN_MATCH != 3</h1>

<pre><code>Call UPDATE_HASH() MIN_MATCH-3 more times
</code></pre>

<h1 id="endif">endif</h1></div></div><div class="code"><div class="wrapper">      <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="cm">/* No match, output a literal byte */</span>
      <span class="nx">flush</span> <span class="o">=</span> <span class="nx">zip_ct_tally</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">zip_window</span><span class="p">[</span><span class="nx">zip_strstart</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
      <span class="nx">zip_lookahead</span><span class="o">--</span><span class="p">;</span>
      <span class="nx">zip_strstart</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">flush</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">zip_flush_block</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="nx">zip_block_start</span> <span class="o">=</span> <span class="nx">zip_strstart</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* Make sure that we always have enough lookahead, except</span>
<span class="cm">   * at the end of the input file. We need MAX_MATCH bytes</span>
<span class="cm">   * for the next match, plus MIN_MATCH bytes to insert the</span>
<span class="cm">   * string following the next match.</span>
<span class="cm">   */</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">zip_lookahead</span> <span class="o">&lt;</span> <span class="nx">zip_MIN_LOOKAHEAD</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">zip_eofile</span><span class="p">)</span>
      <span class="nx">zip_fill_window</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_deflate_better</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* Process the input block. */</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">zip_lookahead</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">zip_qhead</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* Insert the string window[strstart .. strstart+2] in the</span>
<span class="cm">   * dictionary, and set hash_head to the head of the hash chain:</span>
<span class="cm">   */</span>
  <span class="nx">zip_INSERT_STRING</span><span class="p">();</span>

  <span class="cm">/* Find the longest match, discarding those &lt;= prev_length.</span>
<span class="cm">   */</span>
  <span class="nx">zip_prev_length</span> <span class="o">=</span> <span class="nx">zip_match_length</span><span class="p">;</span>
  <span class="nx">zip_prev_match</span> <span class="o">=</span> <span class="nx">zip_match_start</span><span class="p">;</span>
  <span class="nx">zip_match_length</span> <span class="o">=</span> <span class="nx">zip_MIN_MATCH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="nx">zip_hash_head</span> <span class="o">!=</span> <span class="nx">zip_NIL</span> <span class="o">&amp;&amp;</span>
     <span class="nx">zip_prev_length</span> <span class="o">&lt;</span> <span class="nx">zip_max_lazy_match</span> <span class="o">&amp;&amp;</span>
     <span class="nx">zip_strstart</span> <span class="o">-</span> <span class="nx">zip_hash_head</span> <span class="o">&lt;=</span> <span class="nx">zip_MAX_DIST</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* To simplify the code, we prevent matches with the string</span>
<span class="cm">       * of window index 0 (in particular we have to avoid a match</span>
<span class="cm">       * of the string with itself at the start of the input file).</span>
<span class="cm">       */</span>
      <span class="nx">zip_match_length</span> <span class="o">=</span> <span class="nx">zip_longest_match</span><span class="p">(</span><span class="nx">zip_hash_head</span><span class="p">);</span>
      <span class="cm">/* longest_match() sets match_start */</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">zip_match_length</span> <span class="o">&gt;</span> <span class="nx">zip_lookahead</span><span class="p">)</span>
    <span class="nx">zip_match_length</span> <span class="o">=</span> <span class="nx">zip_lookahead</span><span class="p">;</span>

      <span class="cm">/* Ignore a length 3 match if it is too distant: */</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">zip_match_length</span> <span class="o">==</span> <span class="nx">zip_MIN_MATCH</span> <span class="o">&amp;&amp;</span>
         <span class="nx">zip_strstart</span> <span class="o">-</span> <span class="nx">zip_match_start</span> <span class="o">&gt;</span> <span class="nx">zip_TOO_FAR</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* If prev_match is also MIN_MATCH, match_start is garbage</span>
<span class="cm">     * but we will ignore the current match anyway.</span>
<span class="cm">     */</span>
    <span class="nx">zip_match_length</span><span class="o">--</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="cm">/* If there was a match at the previous step and the current</span>
<span class="cm">   * match is not better, output the previous match:</span>
<span class="cm">   */</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">zip_prev_length</span> <span class="o">&gt;=</span> <span class="nx">zip_MIN_MATCH</span> <span class="o">&amp;&amp;</span>
     <span class="nx">zip_match_length</span> <span class="o">&lt;=</span> <span class="nx">zip_prev_length</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">flush</span><span class="p">;</span> <span class="c1">// set if current block must be flushed</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><pre><code>check_match(strstart - 1, prev_match, prev_length);
</code></pre></div></div><div class="code"><div class="wrapper">      <span class="nx">flush</span> <span class="o">=</span> <span class="nx">zip_ct_tally</span><span class="p">(</span><span class="nx">zip_strstart</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">zip_prev_match</span><span class="p">,</span>
         <span class="nx">zip_prev_length</span> <span class="o">-</span> <span class="nx">zip_MIN_MATCH</span><span class="p">);</span>

      <span class="cm">/* Insert in hash table all strings up to the end of the match.</span>
<span class="cm">       * strstart-1 and strstart are already inserted.</span>
<span class="cm">       */</span>
      <span class="nx">zip_lookahead</span> <span class="o">-=</span> <span class="nx">zip_prev_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">zip_prev_length</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">do</span> <span class="p">{</span>
    <span class="nx">zip_strstart</span><span class="o">++</span><span class="p">;</span>
    <span class="nx">zip_INSERT_STRING</span><span class="p">();</span>
    <span class="cm">/* strstart never exceeds WSIZE-MAX_MATCH, so there are</span>
<span class="cm">     * always MIN_MATCH bytes ahead. If lookahead &lt; MIN_MATCH</span>
<span class="cm">     * these bytes are garbage, but it does not matter since the</span>
<span class="cm">     * next lookahead bytes will always be emitted as literals.</span>
<span class="cm">     */</span>
      <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="nx">zip_prev_length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
      <span class="nx">zip_match_available</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">zip_match_length</span> <span class="o">=</span> <span class="nx">zip_MIN_MATCH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">zip_strstart</span><span class="o">++</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">flush</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">zip_flush_block</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">zip_block_start</span> <span class="o">=</span> <span class="nx">zip_strstart</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">zip_match_available</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* If there was no match at the previous position, output a</span>
<span class="cm">       * single literal. If there was a match but the current match</span>
<span class="cm">       * is longer, truncate the previous match to a single literal.</span>
<span class="cm">       */</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">zip_ct_tally</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">zip_window</span><span class="p">[</span><span class="nx">zip_strstart</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">zip_flush_block</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="nx">zip_block_start</span> <span class="o">=</span> <span class="nx">zip_strstart</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">zip_strstart</span><span class="o">++</span><span class="p">;</span>
      <span class="nx">zip_lookahead</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="cm">/* There is no previous match to compare with, wait for</span>
<span class="cm">       * the next step to decide.</span>
<span class="cm">       */</span>
      <span class="nx">zip_match_available</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">zip_strstart</span><span class="o">++</span><span class="p">;</span>
      <span class="nx">zip_lookahead</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* Make sure that we always have enough lookahead, except</span>
<span class="cm">   * at the end of the input file. We need MAX_MATCH bytes</span>
<span class="cm">   * for the next match, plus MIN_MATCH bytes to insert the</span>
<span class="cm">   * string following the next match.</span>
<span class="cm">   */</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">zip_lookahead</span> <span class="o">&lt;</span> <span class="nx">zip_MIN_LOOKAHEAD</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">zip_eofile</span><span class="p">)</span>
      <span class="nx">zip_fill_window</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_init_deflate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_eofile</span><span class="p">)</span>
  <span class="k">return</span><span class="p">;</span>
    <span class="nx">zip_bi_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_bi_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_ct_init</span><span class="p">();</span>
    <span class="nx">zip_lm_init</span><span class="p">();</span>

    <span class="nx">zip_qhead</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_outcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_outoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">zip_compr_level</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">{</span>
  <span class="nx">zip_prev_length</span> <span class="o">=</span> <span class="nx">zip_MIN_MATCH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">zip_match_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
  <span class="nx">zip_match_length</span> <span class="o">=</span> <span class="nx">zip_MIN_MATCH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">zip_match_available</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">zip_complete</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Same as above, but achieves better compression. We use a lazy</span>
<span class="cm"> * evaluation for matches: a match is finally adopted only if there is</span>
<span class="cm"> * no better match at the next window position.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_deflate_internal</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="nx">buff_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">zip_initflag</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">zip_init_deflate</span><span class="p">();</span>
        <span class="nx">zip_initflag</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">zip_lookahead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// empty</span>
            <span class="nx">zip_complete</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">((</span><span class="nx">n</span> <span class="o">=</span> <span class="nx">zip_qcopy</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="nx">buff_size</span><span class="p">))</span> <span class="o">==</span> <span class="nx">buff_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">buff_size</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_complete</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">zip_compr_level</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// optimized for speed</span>
        <span class="nx">zip_deflate_fast</span><span class="p">();</span>
    <span class="k">else</span>
        <span class="nx">zip_deflate_better</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_lookahead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">zip_match_available</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">zip_ct_tally</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">zip_window</span><span class="p">[</span><span class="nx">zip_strstart</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nx">zip_flush_block</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="nx">zip_complete</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">n</span> <span class="o">+</span> <span class="nx">zip_qcopy</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">n</span> <span class="o">+</span> <span class="nx">off</span><span class="p">,</span> <span class="nx">buff_size</span> <span class="o">-</span> <span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_qcopy</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="nx">buff_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">;</span>
    
    <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">zip_qhead</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">buff_size</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="nx">buff_size</span> <span class="o">-</span> <span class="nx">n</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">zip_qhead</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span>
            <span class="nx">i</span> <span class="o">=</span> <span class="nx">zip_qhead</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><pre><code> System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);
</code></pre></div></div><div class="code"><div class="wrapper">        <span class="k">for</span><span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">buff</span><span class="p">[</span><span class="nx">off</span> <span class="o">+</span> <span class="nx">n</span> <span class="o">+</span> <span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_qhead</span><span class="p">.</span><span class="nx">ptr</span><span class="p">[</span><span class="nx">zip_qhead</span><span class="p">.</span><span class="nx">off</span> <span class="o">+</span> <span class="nx">j</span><span class="p">];</span>
        <span class="p">}</span>
        
        <span class="nx">zip_qhead</span><span class="p">.</span><span class="nx">off</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
        <span class="nx">zip_qhead</span><span class="p">.</span><span class="nx">len</span> <span class="o">-=</span> <span class="nx">i</span><span class="p">;</span>
        <span class="nx">n</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">zip_qhead</span><span class="p">.</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">p</span><span class="p">;</span>
            <span class="nx">p</span> <span class="o">=</span> <span class="nx">zip_qhead</span><span class="p">;</span>
            <span class="nx">zip_qhead</span> <span class="o">=</span> <span class="nx">zip_qhead</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
            <span class="nx">zip_reuse_queue</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="nx">buff_size</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">zip_outoff</span> <span class="o">&lt;</span> <span class="nx">zip_outcnt</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">i</span> <span class="o">=</span> <span class="nx">buff_size</span> <span class="o">-</span> <span class="nx">n</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">zip_outcnt</span> <span class="o">-</span> <span class="nx">zip_outoff</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">i</span> <span class="o">=</span> <span class="nx">zip_outcnt</span> <span class="o">-</span> <span class="nx">zip_outoff</span><span class="p">;</span>
        <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><pre><code> System.arraycopy(outbuf, outoff, buff, off + n, i);
</code></pre></div></div><div class="code"><div class="wrapper">        <span class="k">for</span><span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">buff</span><span class="p">[</span><span class="nx">off</span> <span class="o">+</span> <span class="nx">n</span> <span class="o">+</span> <span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_outbuf</span><span class="p">[</span><span class="nx">zip_outoff</span> <span class="o">+</span> <span class="nx">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="nx">zip_outoff</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
        <span class="nx">n</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">zip_outcnt</span> <span class="o">==</span> <span class="nx">zip_outoff</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">zip_outcnt</span> <span class="o">=</span> <span class="nx">zip_outoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Allocate the match buffer, initialize the various tables and save the</span>
<span class="cm"> * location of the internal file attribute (ascii/binary) and method</span>
<span class="cm"> * (DEFLATE/STORE).</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_ct_init</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">;</span>  <span class="c1">// iterates over tree elements</span>
    <span class="kd">var</span> <span class="nx">bits</span><span class="p">;</span> <span class="c1">// bit counter</span>
    <span class="kd">var</span> <span class="nx">length</span><span class="p">;</span> <span class="c1">// length value</span>
    <span class="kd">var</span> <span class="nx">code</span><span class="p">;</span> <span class="c1">// code value</span>
    <span class="kd">var</span> <span class="nx">dist</span><span class="p">;</span> <span class="c1">// distance index</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">zip_static_dtree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">dl</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// ct_init already called</span>

    <span class="nx">zip_l_desc</span><span class="p">.</span><span class="nx">dyn_tree</span>   <span class="o">=</span> <span class="nx">zip_dyn_ltree</span><span class="p">;</span>
    <span class="nx">zip_l_desc</span><span class="p">.</span><span class="nx">static_tree</span>  <span class="o">=</span> <span class="nx">zip_static_ltree</span><span class="p">;</span>
    <span class="nx">zip_l_desc</span><span class="p">.</span><span class="nx">extra_bits</span> <span class="o">=</span> <span class="nx">zip_extra_lbits</span><span class="p">;</span>
    <span class="nx">zip_l_desc</span><span class="p">.</span><span class="nx">extra_base</span> <span class="o">=</span> <span class="nx">zip_LITERALS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">zip_l_desc</span><span class="p">.</span><span class="nx">elems</span>    <span class="o">=</span> <span class="nx">zip_L_CODES</span><span class="p">;</span>
    <span class="nx">zip_l_desc</span><span class="p">.</span><span class="nx">max_length</span> <span class="o">=</span> <span class="nx">zip_MAX_BITS</span><span class="p">;</span>
    <span class="nx">zip_l_desc</span><span class="p">.</span><span class="nx">max_code</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="nx">zip_d_desc</span><span class="p">.</span><span class="nx">dyn_tree</span>   <span class="o">=</span> <span class="nx">zip_dyn_dtree</span><span class="p">;</span>
    <span class="nx">zip_d_desc</span><span class="p">.</span><span class="nx">static_tree</span>  <span class="o">=</span> <span class="nx">zip_static_dtree</span><span class="p">;</span>
    <span class="nx">zip_d_desc</span><span class="p">.</span><span class="nx">extra_bits</span> <span class="o">=</span> <span class="nx">zip_extra_dbits</span><span class="p">;</span>
    <span class="nx">zip_d_desc</span><span class="p">.</span><span class="nx">extra_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_d_desc</span><span class="p">.</span><span class="nx">elems</span>    <span class="o">=</span> <span class="nx">zip_D_CODES</span><span class="p">;</span>
    <span class="nx">zip_d_desc</span><span class="p">.</span><span class="nx">max_length</span> <span class="o">=</span> <span class="nx">zip_MAX_BITS</span><span class="p">;</span>
    <span class="nx">zip_d_desc</span><span class="p">.</span><span class="nx">max_code</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="nx">zip_bl_desc</span><span class="p">.</span><span class="nx">dyn_tree</span>  <span class="o">=</span> <span class="nx">zip_bl_tree</span><span class="p">;</span>
    <span class="nx">zip_bl_desc</span><span class="p">.</span><span class="nx">static_tree</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="nx">zip_bl_desc</span><span class="p">.</span><span class="nx">extra_bits</span>  <span class="o">=</span> <span class="nx">zip_extra_blbits</span><span class="p">;</span>
    <span class="nx">zip_bl_desc</span><span class="p">.</span><span class="nx">extra_base</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_bl_desc</span><span class="p">.</span><span class="nx">elems</span>   <span class="o">=</span> <span class="nx">zip_BL_CODES</span><span class="p">;</span>
    <span class="nx">zip_bl_desc</span><span class="p">.</span><span class="nx">max_length</span>  <span class="o">=</span> <span class="nx">zip_MAX_BL_BITS</span><span class="p">;</span>
    <span class="nx">zip_bl_desc</span><span class="p">.</span><span class="nx">max_code</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Initialize the mapping length (0..255) -> length code (0..28)</p></div></div><div class="code"><div class="wrapper">    <span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">code</span> <span class="o">&lt;</span> <span class="nx">zip_LENGTH_CODES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">code</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_base_length</span><span class="p">[</span><span class="nx">code</span><span class="p">]</span> <span class="o">=</span> <span class="nx">length</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">zip_extra_lbits</span><span class="p">[</span><span class="nx">code</span><span class="p">]);</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">zip_length_code</span><span class="p">[</span><span class="nx">length</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">code</span><span class="p">;</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Assert (length == 256, "ct_init: length != 256");</p></div></div><div class="code"><div class="wrapper">    <span class="cm">/* Note that the length 255 (match length 258) can be represented</span>
<span class="cm">     * in two different ways: code 284 + 5 bits or code 285, so we</span>
<span class="cm">     * overwrite length_code[255] to use the best encoding:</span>
<span class="cm">     */</span>
    <span class="nx">zip_length_code</span><span class="p">[</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">code</span><span class="p">;</span>

    <span class="cm">/* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */</span>
    <span class="nx">dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">code</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="nx">code</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="nx">code</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_base_dist</span><span class="p">[</span><span class="nx">code</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dist</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">zip_extra_dbits</span><span class="p">[</span><span class="nx">code</span><span class="p">]);</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">zip_dist_code</span><span class="p">[</span><span class="nx">dist</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">code</span><span class="p">;</span>
  <span class="p">}</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Assert (dist == 256, "ct_init: dist != 256");</p></div></div><div class="code"><div class="wrapper">    <span class="nx">dist</span> <span class="o">&gt;&gt;=</span> <span class="mi">7</span><span class="p">;</span> <span class="c1">// from now on, all distances are divided by 128</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="nx">code</span> <span class="o">&lt;</span> <span class="nx">zip_D_CODES</span><span class="p">;</span> <span class="nx">code</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_base_dist</span><span class="p">[</span><span class="nx">code</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dist</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nx">zip_extra_dbits</span><span class="p">[</span><span class="nx">code</span><span class="p">]</span><span class="o">-</span><span class="mi">7</span><span class="p">));</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">zip_dist_code</span><span class="p">[</span><span class="mi">256</span> <span class="o">+</span> <span class="nx">dist</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">code</span><span class="p">;</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Assert (dist == 256, "ct_init: 256+dist != 512");</p></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Construct the codes of the static literal tree</p></div></div><div class="code"><div class="wrapper">    <span class="k">for</span><span class="p">(</span><span class="nx">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">bits</span> <span class="o">&lt;=</span> <span class="nx">zip_MAX_BITS</span><span class="p">;</span> <span class="nx">bits</span><span class="o">++</span><span class="p">)</span>
  <span class="nx">zip_bl_count</span><span class="p">[</span><span class="nx">bits</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">143</span><span class="p">)</span> <span class="p">{</span> <span class="nx">zip_static_ltree</span><span class="p">[</span><span class="nx">n</span><span class="o">++</span><span class="p">].</span><span class="nx">dl</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">zip_bl_count</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span> <span class="nx">zip_static_ltree</span><span class="p">[</span><span class="nx">n</span><span class="o">++</span><span class="p">].</span><span class="nx">dl</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span> <span class="nx">zip_bl_count</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">279</span><span class="p">)</span> <span class="p">{</span> <span class="nx">zip_static_ltree</span><span class="p">[</span><span class="nx">n</span><span class="o">++</span><span class="p">].</span><span class="nx">dl</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="nx">zip_bl_count</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">287</span><span class="p">)</span> <span class="p">{</span> <span class="nx">zip_static_ltree</span><span class="p">[</span><span class="nx">n</span><span class="o">++</span><span class="p">].</span><span class="nx">dl</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">zip_bl_count</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
    <span class="cm">/* Codes 286 and 287 do not exist, but we must include them in the</span>
<span class="cm">     * tree construction to get a canonical Huffman tree (longest code</span>
<span class="cm">     * all ones)</span>
<span class="cm">     */</span>
    <span class="nx">zip_gen_codes</span><span class="p">(</span><span class="nx">zip_static_ltree</span><span class="p">,</span> <span class="nx">zip_L_CODES</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="cm">/* The static distance tree is trivial: */</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">zip_D_CODES</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_static_dtree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">dl</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="nx">zip_static_dtree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">fc</span> <span class="o">=</span> <span class="nx">zip_bi_reverse</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Initialize the first block of the first file:</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_init_block</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Initialize a new block.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_init_block</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">;</span> <span class="c1">// iterates over tree elements</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Initialize the trees.</p></div></div><div class="code"><div class="wrapper">    <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">zip_L_CODES</span><span class="p">;</span>  <span class="nx">n</span><span class="o">++</span><span class="p">)</span> <span class="nx">zip_dyn_ltree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">fc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">zip_D_CODES</span><span class="p">;</span>  <span class="nx">n</span><span class="o">++</span><span class="p">)</span> <span class="nx">zip_dyn_dtree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">fc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">zip_BL_CODES</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span> <span class="nx">zip_bl_tree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">fc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="nx">zip_dyn_ltree</span><span class="p">[</span><span class="nx">zip_END_BLOCK</span><span class="p">].</span><span class="nx">fc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">zip_opt_len</span> <span class="o">=</span> <span class="nx">zip_static_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_last_lit</span> <span class="o">=</span> <span class="nx">zip_last_dist</span> <span class="o">=</span> <span class="nx">zip_last_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_flag_bit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Restore the heap property by moving down the tree starting at node k,</span>
<span class="cm"> * exchanging a node with the smallest of its two sons if necessary, stopping</span>
<span class="cm"> * when the heap property is re-established (each father smaller than its</span>
<span class="cm"> * two sons).</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_pqdownheap</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span>
    <span class="nx">tree</span><span class="p">,</span> <span class="c1">// the tree to restore</span>
    <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// node to move down</span>
    <span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">k</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// left son of k</span>

    <span class="k">while</span><span class="p">(</span><span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">zip_heap_len</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Set j to the smallest of the two sons:</p></div></div><div class="code"><div class="wrapper">  <span class="k">if</span><span class="p">(</span><span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">zip_heap_len</span> <span class="o">&amp;&amp;</span>
     <span class="nx">zip_SMALLER</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">j</span><span class="p">]))</span>
      <span class="nx">j</span><span class="o">++</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Exit if v is smaller than both sons</p></div></div><div class="code"><div class="wrapper">  <span class="k">if</span><span class="p">(</span><span class="nx">zip_SMALLER</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">j</span><span class="p">]))</span>
      <span class="k">break</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Exchange v with the smallest son</p></div></div><div class="code"><div class="wrapper">  <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
  <span class="nx">k</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>And continue down the tree, setting j to the left son of k</p></div></div><div class="code"><div class="wrapper">  <span class="nx">j</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Compute the optimal bit lengths for a tree and update the total bit length</span>
<span class="cm"> * for the current block.</span>
<span class="cm"> * IN assertion: the fields freq and dad are set, heap[heap_max] and</span>
<span class="cm"> *    above are the tree nodes sorted by increasing frequency.</span>
<span class="cm"> * OUT assertions: the field len is set to the optimal bit length, the</span>
<span class="cm"> *     array bl_count contains the frequencies for each bit length.</span>
<span class="cm"> *     The length opt_len is updated; static_len is also updated if stree is</span>
<span class="cm"> *     not null.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_gen_bitlen</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">desc</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// the tree descriptor</span>
    <span class="kd">var</span> <span class="nx">tree</span>    <span class="o">=</span> <span class="nx">desc</span><span class="p">.</span><span class="nx">dyn_tree</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">extra</span>   <span class="o">=</span> <span class="nx">desc</span><span class="p">.</span><span class="nx">extra_bits</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">base</span>    <span class="o">=</span> <span class="nx">desc</span><span class="p">.</span><span class="nx">extra_base</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">max_code</span>  <span class="o">=</span> <span class="nx">desc</span><span class="p">.</span><span class="nx">max_code</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">max_length</span>  <span class="o">=</span> <span class="nx">desc</span><span class="p">.</span><span class="nx">max_length</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">stree</span>   <span class="o">=</span> <span class="nx">desc</span><span class="p">.</span><span class="nx">static_tree</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">h</span><span class="p">;</span>    <span class="c1">// heap index</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">;</span>   <span class="c1">// iterate over the tree elements</span>
    <span class="kd">var</span> <span class="nx">bits</span><span class="p">;</span>   <span class="c1">// bit length</span>
    <span class="kd">var</span> <span class="nx">xbits</span><span class="p">;</span>    <span class="c1">// extra bits</span>
    <span class="kd">var</span> <span class="nx">f</span><span class="p">;</span>    <span class="c1">// frequency</span>
    <span class="kd">var</span> <span class="nx">overflow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// number of elements with bit length too large</span>

    <span class="k">for</span><span class="p">(</span><span class="nx">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">bits</span> <span class="o">&lt;=</span> <span class="nx">zip_MAX_BITS</span><span class="p">;</span> <span class="nx">bits</span><span class="o">++</span><span class="p">)</span>
  <span class="nx">zip_bl_count</span><span class="p">[</span><span class="nx">bits</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* In a first pass, compute the optimal bit lengths (which may</span>
<span class="cm">     * overflow in the case of the bit length tree).</span>
<span class="cm">     */</span>
    <span class="nx">tree</span><span class="p">[</span><span class="nx">zip_heap</span><span class="p">[</span><span class="nx">zip_heap_max</span><span class="p">]].</span><span class="nx">dl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// root of the heap</span>

    <span class="k">for</span><span class="p">(</span><span class="nx">h</span> <span class="o">=</span> <span class="nx">zip_heap_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">h</span> <span class="o">&lt;</span> <span class="nx">zip_HEAP_SIZE</span><span class="p">;</span> <span class="nx">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">=</span> <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">h</span><span class="p">];</span>
  <span class="nx">bits</span> <span class="o">=</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">tree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">dl</span><span class="p">].</span><span class="nx">dl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">bits</span> <span class="o">&gt;</span> <span class="nx">max_length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">bits</span> <span class="o">=</span> <span class="nx">max_length</span><span class="p">;</span>
      <span class="nx">overflow</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">tree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">dl</span> <span class="o">=</span> <span class="nx">bits</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We overwrite tree[n].dl which is no longer needed</p></div></div><div class="code"><div class="wrapper">  <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">&gt;</span> <span class="nx">max_code</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span> <span class="c1">// not a leaf node</span>

  <span class="nx">zip_bl_count</span><span class="p">[</span><span class="nx">bits</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
  <span class="nx">xbits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">&gt;=</span> <span class="nx">base</span><span class="p">)</span>
      <span class="nx">xbits</span> <span class="o">=</span> <span class="nx">extra</span><span class="p">[</span><span class="nx">n</span> <span class="o">-</span> <span class="nx">base</span><span class="p">];</span>
  <span class="nx">f</span> <span class="o">=</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">fc</span><span class="p">;</span>
  <span class="nx">zip_opt_len</span> <span class="o">+=</span> <span class="nx">f</span> <span class="o">*</span> <span class="p">(</span><span class="nx">bits</span> <span class="o">+</span> <span class="nx">xbits</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">stree</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
      <span class="nx">zip_static_len</span> <span class="o">+=</span> <span class="nx">f</span> <span class="o">*</span> <span class="p">(</span><span class="nx">stree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">dl</span> <span class="o">+</span> <span class="nx">xbits</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">overflow</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>This happens for example on obj2 and pic of the Calgary corpus</p></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Find the first bit length which could increase:</p></div></div><div class="code"><div class="wrapper">    <span class="k">do</span> <span class="p">{</span>
  <span class="nx">bits</span> <span class="o">=</span> <span class="nx">max_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">zip_bl_count</span><span class="p">[</span><span class="nx">bits</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nx">bits</span><span class="o">--</span><span class="p">;</span>
  <span class="nx">zip_bl_count</span><span class="p">[</span><span class="nx">bits</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>   <span class="c1">// move one leaf down the tree</span>
  <span class="nx">zip_bl_count</span><span class="p">[</span><span class="nx">bits</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// move one overflow item as its brother</span>
  <span class="nx">zip_bl_count</span><span class="p">[</span><span class="nx">max_length</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
  <span class="cm">/* The brother of the overflow item also moves one step up,</span>
<span class="cm">   * but this does not affect bl_count[max_length]</span>
<span class="cm">   */</span>
  <span class="nx">overflow</span> <span class="o">-=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="nx">overflow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="cm">/* Now recompute all bit lengths, scanning in increasing frequency.</span>
<span class="cm">     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all</span>
<span class="cm">     * lengths instead of fixing only the wrong ones. This idea is taken</span>
<span class="cm">     * from &#39;ar&#39; written by Haruhiko Okumura.)</span>
<span class="cm">     */</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">bits</span> <span class="o">=</span> <span class="nx">max_length</span><span class="p">;</span> <span class="nx">bits</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">bits</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">=</span> <span class="nx">zip_bl_count</span><span class="p">[</span><span class="nx">bits</span><span class="p">];</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">m</span> <span class="o">=</span> <span class="nx">zip_heap</span><span class="p">[</span><span class="o">--</span><span class="nx">h</span><span class="p">];</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">m</span> <span class="o">&gt;</span> <span class="nx">max_code</span><span class="p">)</span>
    <span class="k">continue</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">tree</span><span class="p">[</span><span class="nx">m</span><span class="p">].</span><span class="nx">dl</span> <span class="o">!=</span> <span class="nx">bits</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">zip_opt_len</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">bits</span> <span class="o">-</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">m</span><span class="p">].</span><span class="nx">dl</span><span class="p">)</span> <span class="o">*</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">m</span><span class="p">].</span><span class="nx">fc</span><span class="p">;</span>
    <span class="nx">tree</span><span class="p">[</span><span class="nx">m</span><span class="p">].</span><span class="nx">fc</span> <span class="o">=</span> <span class="nx">bits</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">n</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

  <span class="cm">/* ==========================================================================</span>
<span class="cm">   * Generate the codes for a given tree and bit counts (which need not be</span>
<span class="cm">   * optimal).</span>
<span class="cm">   * IN assertion: the array bl_count contains the bit length statistics for</span>
<span class="cm">   * the given tree and the field len is set for all tree elements.</span>
<span class="cm">   * OUT assertion: the field code is set for all tree elements of non</span>
<span class="cm">   *     zero code length.</span>
<span class="cm">   */</span>
<span class="kd">var</span> <span class="nx">zip_gen_codes</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span>  <span class="c1">// the tree to decorate</span>
       <span class="nx">max_code</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// largest code with non zero frequency</span>
    <span class="kd">var</span> <span class="nx">next_code</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">zip_MAX_BITS</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// next code value for each bit length</span>
    <span class="kd">var</span> <span class="nx">code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// running code value</span>
    <span class="kd">var</span> <span class="nx">bits</span><span class="p">;</span>     <span class="c1">// bit index</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">;</span>      <span class="c1">// code index</span>

    <span class="cm">/* The distribution counts are first used to generate the code values</span>
<span class="cm">     * without bit reversal.</span>
<span class="cm">     */</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">bits</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">bits</span> <span class="o">&lt;=</span> <span class="nx">zip_MAX_BITS</span><span class="p">;</span> <span class="nx">bits</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">code</span> <span class="o">=</span> <span class="p">((</span><span class="nx">code</span> <span class="o">+</span> <span class="nx">zip_bl_count</span><span class="p">[</span><span class="nx">bits</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
  <span class="nx">next_code</span><span class="p">[</span><span class="nx">bits</span><span class="p">]</span> <span class="o">=</span> <span class="nx">code</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Check that the bit counts in bl_count are consistent. The last code</span>
<span class="cm">     * must be all ones.</span>
<span class="cm">     */</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Assert (code + encoder->bl<em>count[MAX</em>BITS]-1 == (1&lt;<MAX<em>BITS)-1,
    "inconsistent bit counts");
   Tracev((stderr,"\ngen</em>codes: max<em>code %d ", max</em>code));</p></div></div><div class="code"><div class="wrapper">    <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nx">max_code</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">dl</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Now reverse the bits</p></div></div><div class="code"><div class="wrapper">  <span class="nx">tree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">fc</span> <span class="o">=</span> <span class="nx">zip_bi_reverse</span><span class="p">(</span><span class="nx">next_code</span><span class="p">[</span><span class="nx">len</span><span class="p">]</span><span class="o">++</span><span class="p">,</span> <span class="nx">len</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><pre><code> Tracec(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
</code></pre>

<p>n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));</p></div></div><div class="code"><div class="wrapper">    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Construct one Huffman tree and assigns the code bit strings and lengths.</span>
<span class="cm"> * Update the total bit length for the current block.</span>
<span class="cm"> * IN assertion: the field freq is set for all tree elements.</span>
<span class="cm"> * OUT assertions: the fields len and code are set to the optimal bit length</span>
<span class="cm"> *     and corresponding code. The length opt_len is updated; static_len is</span>
<span class="cm"> *     also updated if stree is not null. The field max_code is set.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_build_tree</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">desc</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// the tree descriptor</span>
    <span class="kd">var</span> <span class="nx">tree</span>  <span class="o">=</span> <span class="nx">desc</span><span class="p">.</span><span class="nx">dyn_tree</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">stree</span> <span class="o">=</span> <span class="nx">desc</span><span class="p">.</span><span class="nx">static_tree</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">elems</span> <span class="o">=</span> <span class="nx">desc</span><span class="p">.</span><span class="nx">elems</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">;</span>   <span class="c1">// iterate over heap elements</span>
    <span class="kd">var</span> <span class="nx">max_code</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// largest code with non zero frequency</span>
    <span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">elems</span><span class="p">;</span> <span class="c1">// next internal node of the tree</span>

    <span class="cm">/* Construct the initial heap, with least frequent element in</span>
<span class="cm">     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].</span>
<span class="cm">     * heap[0] is not used.</span>
<span class="cm">     */</span>
    <span class="nx">zip_heap_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_heap_max</span> <span class="o">=</span> <span class="nx">zip_HEAP_SIZE</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">elems</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">tree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">fc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">zip_heap</span><span class="p">[</span><span class="o">++</span><span class="nx">zip_heap_len</span><span class="p">]</span> <span class="o">=</span> <span class="nx">max_code</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
      <span class="nx">zip_depth</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span>
      <span class="nx">tree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">dl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* The pkzip format requires that at least one distance code exists,</span>
<span class="cm">     * and that at least one bit should be sent even if there is only one</span>
<span class="cm">     * possible code. So to avoid special checks later on we force at least</span>
<span class="cm">     * two codes of non zero frequency.</span>
<span class="cm">     */</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">zip_heap_len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">xnew</span> <span class="o">=</span> <span class="nx">zip_heap</span><span class="p">[</span><span class="o">++</span><span class="nx">zip_heap_len</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">max_code</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">?</span> <span class="o">++</span><span class="nx">max_code</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
  <span class="nx">tree</span><span class="p">[</span><span class="nx">xnew</span><span class="p">].</span><span class="nx">fc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">zip_depth</span><span class="p">[</span><span class="nx">xnew</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">zip_opt_len</span><span class="o">--</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">stree</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
      <span class="nx">zip_static_len</span> <span class="o">-=</span> <span class="nx">stree</span><span class="p">[</span><span class="nx">xnew</span><span class="p">].</span><span class="nx">dl</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>new is 0 or 1 so it does not have extra bits</p></div></div><div class="code"><div class="wrapper">    <span class="p">}</span>
    <span class="nx">desc</span><span class="p">.</span><span class="nx">max_code</span> <span class="o">=</span> <span class="nx">max_code</span><span class="p">;</span>

    <span class="cm">/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,</span>
<span class="cm">     * establish sub-heaps of increasing lengths:</span>
<span class="cm">     */</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="nx">zip_heap_len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">n</span><span class="o">--</span><span class="p">)</span>
  <span class="nx">zip_pqdownheap</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span>

    <span class="cm">/* Construct the Huffman tree by repeatedly combining the least two</span>
<span class="cm">     * frequent nodes.</span>
<span class="cm">     */</span>
    <span class="k">do</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">=</span> <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">zip_SMALLEST</span><span class="p">];</span>
  <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">zip_SMALLEST</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">zip_heap_len</span><span class="o">--</span><span class="p">];</span>
  <span class="nx">zip_pqdownheap</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">zip_SMALLEST</span><span class="p">);</span>

  <span class="nx">m</span> <span class="o">=</span> <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">zip_SMALLEST</span><span class="p">];</span>  <span class="c1">// m = node of next least frequency</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>keep the nodes sorted by frequency</p></div></div><div class="code"><div class="wrapper">  <span class="nx">zip_heap</span><span class="p">[</span><span class="o">--</span><span class="nx">zip_heap_max</span><span class="p">]</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
  <span class="nx">zip_heap</span><span class="p">[</span><span class="o">--</span><span class="nx">zip_heap_max</span><span class="p">]</span> <span class="o">=</span> <span class="nx">m</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Create a new node father of n and m</p></div></div><div class="code"><div class="wrapper">  <span class="nx">tree</span><span class="p">[</span><span class="nx">node</span><span class="p">].</span><span class="nx">fc</span> <span class="o">=</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">fc</span> <span class="o">+</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">m</span><span class="p">].</span><span class="nx">fc</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>depth[node] = (char)(MAX(depth[n], depth[m]) + 1);</p></div></div><div class="code"><div class="wrapper">  <span class="k">if</span><span class="p">(</span><span class="nx">zip_depth</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">zip_depth</span><span class="p">[</span><span class="nx">m</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="nx">zip_depth</span><span class="p">[</span><span class="nx">node</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_depth</span><span class="p">[</span><span class="nx">n</span><span class="p">];</span>
  <span class="k">else</span>
      <span class="nx">zip_depth</span><span class="p">[</span><span class="nx">node</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_depth</span><span class="p">[</span><span class="nx">m</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">tree</span><span class="p">[</span><span class="nx">n</span><span class="p">].</span><span class="nx">dl</span> <span class="o">=</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">m</span><span class="p">].</span><span class="nx">dl</span> <span class="o">=</span> <span class="nx">node</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>and insert the new node in the heap</p></div></div><div class="code"><div class="wrapper">  <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">zip_SMALLEST</span><span class="p">]</span> <span class="o">=</span> <span class="nx">node</span><span class="o">++</span><span class="p">;</span>
  <span class="nx">zip_pqdownheap</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">zip_SMALLEST</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="nx">zip_heap_len</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>

    <span class="nx">zip_heap</span><span class="p">[</span><span class="o">--</span><span class="nx">zip_heap_max</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_heap</span><span class="p">[</span><span class="nx">zip_SMALLEST</span><span class="p">];</span>

    <span class="cm">/* At this point, the fields freq and dad are set. We can now</span>
<span class="cm">     * generate the bit lengths.</span>
<span class="cm">     */</span>
    <span class="nx">zip_gen_bitlen</span><span class="p">(</span><span class="nx">desc</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>The field len is now set, we can generate the bit codes</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_gen_codes</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">max_code</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Scan a literal or distance tree to determine the frequencies of the codes</span>
<span class="cm"> * in the bit length tree. Updates opt_len to take into account the repeat</span>
<span class="cm"> * counts. (The contribution of the bit length codes will be added later</span>
<span class="cm"> * during the construction of bl_tree.)</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_scan_tree</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span><span class="c1">// the tree to be scanned</span>
           <span class="nx">max_code</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// and its largest code of non zero frequency</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">;</span>      <span class="c1">// iterates over all tree elements</span>
    <span class="kd">var</span> <span class="nx">prevlen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>   <span class="c1">// last emitted length</span>
    <span class="kd">var</span> <span class="nx">curlen</span><span class="p">;</span>     <span class="c1">// length of current code</span>
    <span class="kd">var</span> <span class="nx">nextlen</span> <span class="o">=</span> <span class="nx">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">dl</span><span class="p">;</span> <span class="c1">// length of next code</span>
    <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// repeat count of the current code</span>
    <span class="kd">var</span> <span class="nx">max_count</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>    <span class="c1">// max repeat count</span>
    <span class="kd">var</span> <span class="nx">min_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>    <span class="c1">// min repeat count</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">nextlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">max_count</span> <span class="o">=</span> <span class="mi">138</span><span class="p">;</span>
  <span class="nx">min_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">tree</span><span class="p">[</span><span class="nx">max_code</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="nx">dl</span> <span class="o">=</span> <span class="mh">0xffff</span><span class="p">;</span> <span class="c1">// guard</span>

    <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nx">max_code</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">curlen</span> <span class="o">=</span> <span class="nx">nextlen</span><span class="p">;</span>
  <span class="nx">nextlen</span> <span class="o">=</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="nx">dl</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="nx">count</span> <span class="o">&lt;</span> <span class="nx">max_count</span> <span class="o">&amp;&amp;</span> <span class="nx">curlen</span> <span class="o">==</span> <span class="nx">nextlen</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">count</span> <span class="o">&lt;</span> <span class="nx">min_count</span><span class="p">)</span>
      <span class="nx">zip_bl_tree</span><span class="p">[</span><span class="nx">curlen</span><span class="p">].</span><span class="nx">fc</span> <span class="o">+=</span> <span class="nx">count</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">curlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">curlen</span> <span class="o">!=</span> <span class="nx">prevlen</span><span class="p">)</span>
    <span class="nx">zip_bl_tree</span><span class="p">[</span><span class="nx">curlen</span><span class="p">].</span><span class="nx">fc</span><span class="o">++</span><span class="p">;</span>
      <span class="nx">zip_bl_tree</span><span class="p">[</span><span class="nx">zip_REP_3_6</span><span class="p">].</span><span class="nx">fc</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">count</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span>
      <span class="nx">zip_bl_tree</span><span class="p">[</span><span class="nx">zip_REPZ_3_10</span><span class="p">].</span><span class="nx">fc</span><span class="o">++</span><span class="p">;</span>
  <span class="k">else</span>
      <span class="nx">zip_bl_tree</span><span class="p">[</span><span class="nx">zip_REPZ_11_138</span><span class="p">].</span><span class="nx">fc</span><span class="o">++</span><span class="p">;</span>
  <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">prevlen</span> <span class="o">=</span> <span class="nx">curlen</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">nextlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">max_count</span> <span class="o">=</span> <span class="mi">138</span><span class="p">;</span>
      <span class="nx">min_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">curlen</span> <span class="o">==</span> <span class="nx">nextlen</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">max_count</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
      <span class="nx">min_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">max_count</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
      <span class="nx">min_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

  <span class="cm">/* ==========================================================================</span>
<span class="cm">   * Send a literal or distance tree in compressed form, using the codes in</span>
<span class="cm">   * bl_tree.</span>
<span class="cm">   */</span>
<span class="kd">var</span> <span class="nx">zip_send_tree</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="c1">// the tree to be scanned</span>
       <span class="nx">max_code</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// and its largest code of non zero frequency</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">;</span>      <span class="c1">// iterates over all tree elements</span>
    <span class="kd">var</span> <span class="nx">prevlen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>   <span class="c1">// last emitted length</span>
    <span class="kd">var</span> <span class="nx">curlen</span><span class="p">;</span>     <span class="c1">// length of current code</span>
    <span class="kd">var</span> <span class="nx">nextlen</span> <span class="o">=</span> <span class="nx">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">dl</span><span class="p">;</span> <span class="c1">// length of next code</span>
    <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// repeat count of the current code</span>
    <span class="kd">var</span> <span class="nx">max_count</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>    <span class="c1">// max repeat count</span>
    <span class="kd">var</span> <span class="nx">min_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>    <span class="c1">// min repeat count</span>

    <span class="cm">/* tree[max_code+1].dl = -1; */</span>  <span class="cm">/* guard already set */</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">nextlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">max_count</span> <span class="o">=</span> <span class="mi">138</span><span class="p">;</span>
      <span class="nx">min_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="nx">max_code</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">curlen</span> <span class="o">=</span> <span class="nx">nextlen</span><span class="p">;</span>
  <span class="nx">nextlen</span> <span class="o">=</span> <span class="nx">tree</span><span class="p">[</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">dl</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="nx">count</span> <span class="o">&lt;</span> <span class="nx">max_count</span> <span class="o">&amp;&amp;</span> <span class="nx">curlen</span> <span class="o">==</span> <span class="nx">nextlen</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">count</span> <span class="o">&lt;</span> <span class="nx">min_count</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">do</span> <span class="p">{</span> <span class="nx">zip_SEND_CODE</span><span class="p">(</span><span class="nx">curlen</span><span class="p">,</span> <span class="nx">zip_bl_tree</span><span class="p">);</span> <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="nx">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">curlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">curlen</span> <span class="o">!=</span> <span class="nx">prevlen</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">zip_SEND_CODE</span><span class="p">(</span><span class="nx">curlen</span><span class="p">,</span> <span class="nx">zip_bl_tree</span><span class="p">);</span>
    <span class="nx">count</span><span class="o">--</span><span class="p">;</span>
      <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Assert(count >= 3 &amp;&amp; count &lt;= 6, " 3_6?");</p></div></div><div class="code"><div class="wrapper">      <span class="nx">zip_SEND_CODE</span><span class="p">(</span><span class="nx">zip_REP_3_6</span><span class="p">,</span> <span class="nx">zip_bl_tree</span><span class="p">);</span>
      <span class="nx">zip_send_bits</span><span class="p">(</span><span class="nx">count</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">count</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">zip_SEND_CODE</span><span class="p">(</span><span class="nx">zip_REPZ_3_10</span><span class="p">,</span> <span class="nx">zip_bl_tree</span><span class="p">);</span>
      <span class="nx">zip_send_bits</span><span class="p">(</span><span class="nx">count</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">zip_SEND_CODE</span><span class="p">(</span><span class="nx">zip_REPZ_11_138</span><span class="p">,</span> <span class="nx">zip_bl_tree</span><span class="p">);</span>
      <span class="nx">zip_send_bits</span><span class="p">(</span><span class="nx">count</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">prevlen</span> <span class="o">=</span> <span class="nx">curlen</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">nextlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">max_count</span> <span class="o">=</span> <span class="mi">138</span><span class="p">;</span>
      <span class="nx">min_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">curlen</span> <span class="o">==</span> <span class="nx">nextlen</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">max_count</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
      <span class="nx">min_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">max_count</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
      <span class="nx">min_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Construct the Huffman tree for the bit lengths and return the index in</span>
<span class="cm"> * bl_order of the last bit length code to send.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_build_bl_tree</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">max_blindex</span><span class="p">;</span>  <span class="c1">// index of last bit length code of non zero freq</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Determine the bit length frequencies for literal and distance trees</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_scan_tree</span><span class="p">(</span><span class="nx">zip_dyn_ltree</span><span class="p">,</span> <span class="nx">zip_l_desc</span><span class="p">.</span><span class="nx">max_code</span><span class="p">);</span>
    <span class="nx">zip_scan_tree</span><span class="p">(</span><span class="nx">zip_dyn_dtree</span><span class="p">,</span> <span class="nx">zip_d_desc</span><span class="p">.</span><span class="nx">max_code</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Build the bit length tree:</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_build_tree</span><span class="p">(</span><span class="nx">zip_bl_desc</span><span class="p">);</span>
    <span class="cm">/* opt_len now includes the length of the tree representations, except</span>
<span class="cm">     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.</span>
<span class="cm">     */</span>

    <span class="cm">/* Determine the number of bit length codes to send. The pkzip format</span>
<span class="cm">     * requires that at least 4 bit length codes be sent. (appnote.txt says</span>
<span class="cm">     * 3 but the actual value used is 4.)</span>
<span class="cm">     */</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">max_blindex</span> <span class="o">=</span> <span class="nx">zip_BL_CODES</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">max_blindex</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">max_blindex</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">zip_bl_tree</span><span class="p">[</span><span class="nx">zip_bl_order</span><span class="p">[</span><span class="nx">max_blindex</span><span class="p">]].</span><span class="nx">dl</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* Update opt_len to include the bit length tree and counts */</span>
    <span class="nx">zip_opt_len</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="nx">max_blindex</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="o">+</span><span class="mi">5</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
    encoder->opt<em>len, encoder->static</em>len));</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="nx">max_blindex</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Send the header for a block using dynamic Huffman trees: the counts, the</span>
<span class="cm"> * lengths of the bit length codes, the literal tree and the distance tree.</span>
<span class="cm"> * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_send_all_trees</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">lcodes</span><span class="p">,</span> <span class="nx">dcodes</span><span class="p">,</span> <span class="nx">blcodes</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// number of codes for each tree</span>
    <span class="kd">var</span> <span class="nx">rank</span><span class="p">;</span> <span class="c1">// index in bl_order</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Assert (lcodes >= 257 &amp;&amp; dcodes >= 1 &amp;&amp; blcodes >= 4, "not enough codes");
   Assert (lcodes &lt;= L<em>CODES &amp;&amp; dcodes &lt;= D</em>CODES &amp;&amp; blcodes &lt;= BL_CODES,
    "too many codes");
   Tracev((stderr, "\nbl counts: "));</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_send_bits</span><span class="p">(</span><span class="nx">lcodes</span><span class="o">-</span><span class="mi">257</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// not +255 as stated in appnote.txt</span>
    <span class="nx">zip_send_bits</span><span class="p">(</span><span class="nx">dcodes</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>   <span class="mi">5</span><span class="p">);</span>
    <span class="nx">zip_send_bits</span><span class="p">(</span><span class="nx">blcodes</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span>  <span class="mi">4</span><span class="p">);</span> <span class="c1">// not -3 as stated in appnote.txt</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">rank</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">rank</span> <span class="o">&lt;</span> <span class="nx">blcodes</span><span class="p">;</span> <span class="nx">rank</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><pre><code> Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
</code></pre></div></div><div class="code"><div class="wrapper">  <span class="nx">zip_send_bits</span><span class="p">(</span><span class="nx">zip_bl_tree</span><span class="p">[</span><span class="nx">zip_bl_order</span><span class="p">[</span><span class="nx">rank</span><span class="p">]].</span><span class="nx">dl</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>send the literal tree</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_send_tree</span><span class="p">(</span><span class="nx">zip_dyn_ltree</span><span class="p">,</span><span class="nx">lcodes</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>send the distance tree</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_send_tree</span><span class="p">(</span><span class="nx">zip_dyn_dtree</span><span class="p">,</span><span class="nx">dcodes</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Determine the best encoding for the current block: dynamic trees, static</span>
<span class="cm"> * trees or store, and output the encoded block to the zip file.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_flush_block</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">eof</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// true if this is the last block for a file</span>
    <span class="kd">var</span> <span class="nx">opt_lenb</span><span class="p">,</span> <span class="nx">static_lenb</span><span class="p">;</span> <span class="c1">// opt_len and static_len in bytes</span>
    <span class="kd">var</span> <span class="nx">max_blindex</span><span class="p">;</span>  <span class="c1">// index of last bit length code of non zero freq</span>
    <span class="kd">var</span> <span class="nx">stored_len</span><span class="p">;</span> <span class="c1">// length of input block</span>

    <span class="nx">stored_len</span> <span class="o">=</span> <span class="nx">zip_strstart</span> <span class="o">-</span> <span class="nx">zip_block_start</span><span class="p">;</span>
    <span class="nx">zip_flag_buf</span><span class="p">[</span><span class="nx">zip_last_flags</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_flags</span><span class="p">;</span> <span class="c1">// Save the flags for the last 8 items</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Construct the literal and distance trees</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_build_tree</span><span class="p">(</span><span class="nx">zip_l_desc</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Tracev((stderr, "\nlit data: dyn %ld, stat %ld",
    encoder->opt<em>len, encoder->static</em>len));</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_build_tree</span><span class="p">(</span><span class="nx">zip_d_desc</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Tracev((stderr, "\ndist data: dyn %ld, stat %ld",
    encoder->opt<em>len, encoder->static</em>len));</p></div></div><div class="code"><div class="wrapper">    <span class="cm">/* At this point, opt_len and static_len are the total bit lengths of</span>
<span class="cm">     * the compressed block data, excluding the tree representations.</span>
<span class="cm">     */</span>

    <span class="cm">/* Build the bit length tree for the above two trees, and get the index</span>
<span class="cm">     * in bl_order of the last bit length code to send.</span>
<span class="cm">     */</span>
    <span class="nx">max_blindex</span> <span class="o">=</span> <span class="nx">zip_build_bl_tree</span><span class="p">();</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Determine the best encoding. Compute first the block length in bytes</p></div></div><div class="code"><div class="wrapper">    <span class="nx">opt_lenb</span>  <span class="o">=</span> <span class="p">(</span><span class="nx">zip_opt_len</span>   <span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">;</span>
    <span class="nx">static_lenb</span> <span class="o">=</span> <span class="p">(</span><span class="nx">zip_static_len</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Trace((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ",
   opt<em>lenb, encoder->opt</em>len,
   static<em>lenb, encoder->static</em>len, stored<em>len,
   encoder->last</em>lit, encoder->last_dist));</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span><span class="p">(</span><span class="nx">static_lenb</span> <span class="o">&lt;=</span> <span class="nx">opt_lenb</span><span class="p">)</span>
  <span class="nx">opt_lenb</span> <span class="o">=</span> <span class="nx">static_lenb</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">stored_len</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">&lt;=</span> <span class="nx">opt_lenb</span> <span class="c1">// 4: two words for the lengths</span>
       <span class="o">&amp;&amp;</span> <span class="nx">zip_block_start</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>

  <span class="cm">/* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.</span>
<span class="cm">   * Otherwise we can&#39;t have processed more than WSIZE input bytes since</span>
<span class="cm">   * the last block flush, because compression would have been</span>
<span class="cm">   * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to</span>
<span class="cm">   * transform a block into a stored block.</span>
<span class="cm">   */</span>
  <span class="nx">zip_send_bits</span><span class="p">((</span><span class="nx">zip_STORED_BLOCK</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="nx">eof</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>  <span class="cm">/* send block type */</span>
  <span class="nx">zip_bi_windup</span><span class="p">();</span>     <span class="cm">/* align on byte boundary */</span>
  <span class="nx">zip_put_short</span><span class="p">(</span><span class="nx">stored_len</span><span class="p">);</span>
  <span class="nx">zip_put_short</span><span class="p">(</span><span class="o">~</span><span class="nx">stored_len</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>copy block</p></div></div><div class="code"><div class="wrapper"><span class="cm">/*</span>
<span class="cm">      p = &amp;window[block_start];</span>
<span class="cm">      for(i = 0; i &lt; stored_len; i++)</span>
<span class="cm">  put_byte(p[i]);</span>
<span class="cm">*/</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">stored_len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">zip_put_byte</span><span class="p">(</span><span class="nx">zip_window</span><span class="p">[</span><span class="nx">zip_block_start</span> <span class="o">+</span> <span class="nx">i</span><span class="p">]);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">static_lenb</span> <span class="o">==</span> <span class="nx">opt_lenb</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_send_bits</span><span class="p">((</span><span class="nx">zip_STATIC_TREES</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="nx">eof</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="nx">zip_compress_block</span><span class="p">(</span><span class="nx">zip_static_ltree</span><span class="p">,</span> <span class="nx">zip_static_dtree</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">zip_send_bits</span><span class="p">((</span><span class="nx">zip_DYN_TREES</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="nx">eof</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="nx">zip_send_all_trees</span><span class="p">(</span><span class="nx">zip_l_desc</span><span class="p">.</span><span class="nx">max_code</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
         <span class="nx">zip_d_desc</span><span class="p">.</span><span class="nx">max_code</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
         <span class="nx">max_blindex</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
  <span class="nx">zip_compress_block</span><span class="p">(</span><span class="nx">zip_dyn_ltree</span><span class="p">,</span> <span class="nx">zip_dyn_dtree</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">zip_init_block</span><span class="p">();</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">eof</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="nx">zip_bi_windup</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Save the match info and tally the frequency counts. Return true if</span>
<span class="cm"> * the current block must be flushed.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_ct_tally</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span>
  <span class="nx">dist</span><span class="p">,</span> <span class="c1">// distance of matched string</span>
  <span class="nx">lc</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// match length-MIN_MATCH or unmatched char (if dist==0)</span>
    <span class="nx">zip_l_buf</span><span class="p">[</span><span class="nx">zip_last_lit</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">lc</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>lc is the unmatched char</p></div></div><div class="code"><div class="wrapper">  <span class="nx">zip_dyn_ltree</span><span class="p">[</span><span class="nx">lc</span><span class="p">].</span><span class="nx">fc</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Here, lc is the match length - MIN_MATCH</p></div></div><div class="code"><div class="wrapper">  <span class="nx">dist</span><span class="o">--</span><span class="p">;</span>       <span class="c1">// dist = match distance - 1</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><pre><code> Assert((ush)dist &lt; (ush)MAX_DIST &amp;&amp;
 (ush)lc &lt;= (ush)(MAX_MATCH-MIN_MATCH) &amp;&amp;
 (ush)D_CODE(dist) &lt; (ush)D_CODES,  "ct_tally: bad match");
</code></pre></div></div><div class="code"><div class="wrapper">  <span class="nx">zip_dyn_ltree</span><span class="p">[</span><span class="nx">zip_length_code</span><span class="p">[</span><span class="nx">lc</span><span class="p">]</span><span class="o">+</span><span class="nx">zip_LITERALS</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">fc</span><span class="o">++</span><span class="p">;</span>
  <span class="nx">zip_dyn_dtree</span><span class="p">[</span><span class="nx">zip_D_CODE</span><span class="p">(</span><span class="nx">dist</span><span class="p">)].</span><span class="nx">fc</span><span class="o">++</span><span class="p">;</span>

  <span class="nx">zip_d_buf</span><span class="p">[</span><span class="nx">zip_last_dist</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dist</span><span class="p">;</span>
  <span class="nx">zip_flags</span> <span class="o">|=</span> <span class="nx">zip_flag_bit</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">zip_flag_bit</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Output the flags if they fill a byte</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span><span class="p">((</span><span class="nx">zip_last_lit</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_flag_buf</span><span class="p">[</span><span class="nx">zip_last_flags</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_flags</span><span class="p">;</span>
  <span class="nx">zip_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">zip_flag_bit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Try to guess if it is profitable to stop the current block here</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span><span class="p">(</span><span class="nx">zip_compr_level</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">zip_last_lit</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Compute an upper bound for the compressed length</p></div></div><div class="code"><div class="wrapper">  <span class="kd">var</span> <span class="nx">out_length</span> <span class="o">=</span> <span class="nx">zip_last_lit</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">in_length</span> <span class="o">=</span> <span class="nx">zip_strstart</span> <span class="o">-</span> <span class="nx">zip_block_start</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">dcode</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="nx">dcode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">dcode</span> <span class="o">&lt;</span> <span class="nx">zip_D_CODES</span><span class="p">;</span> <span class="nx">dcode</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">out_length</span> <span class="o">+=</span> <span class="nx">zip_dyn_dtree</span><span class="p">[</span><span class="nx">dcode</span><span class="p">].</span><span class="nx">fc</span> <span class="o">*</span> <span class="p">(</span><span class="mi">5</span> <span class="o">+</span> <span class="nx">zip_extra_dbits</span><span class="p">[</span><span class="nx">dcode</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="nx">out_length</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><pre><code> Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ",
 encoder-&gt;last_lit, encoder-&gt;last_dist, in_length, out_length,
 100L - out_length*100L/in_length));
</code></pre></div></div><div class="code"><div class="wrapper">  <span class="k">if</span><span class="p">(</span><span class="nx">zip_last_dist</span> <span class="o">&lt;</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">zip_last_lit</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
     <span class="nx">out_length</span> <span class="o">&lt;</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">in_length</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">zip_last_lit</span> <span class="o">==</span> <span class="nx">zip_LIT_BUFSIZE</span><span class="o">-</span><span class="mi">1</span> <span class="o">||</span>
      <span class="nx">zip_last_dist</span> <span class="o">==</span> <span class="nx">zip_DIST_BUFSIZE</span><span class="p">);</span>
    <span class="cm">/* We avoid equality with LIT_BUFSIZE because of wraparound at 64K</span>
<span class="cm">     * on 16 bit machines and because stored blocks are restricted to</span>
<span class="cm">     * 64K-1 bytes.</span>
<span class="cm">     */</span>
<span class="p">}</span>

  <span class="cm">/* ==========================================================================</span>
<span class="cm">   * Send the block data compressed using the given Huffman trees</span>
<span class="cm">   */</span>
<span class="kd">var</span> <span class="nx">zip_compress_block</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span>
  <span class="nx">ltree</span><span class="p">,</span>  <span class="c1">// literal tree</span>
  <span class="nx">dtree</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// distance tree</span>
    <span class="kd">var</span> <span class="nx">dist</span><span class="p">;</span>   <span class="c1">// distance of matched string</span>
    <span class="kd">var</span> <span class="nx">lc</span><span class="p">;</span>   <span class="c1">// match length or unmatched char (if dist == 0)</span>
    <span class="kd">var</span> <span class="nx">lx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// running index in l_buf</span>
    <span class="kd">var</span> <span class="nx">dx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// running index in d_buf</span>
    <span class="kd">var</span> <span class="nx">fx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// running index in flag_buf</span>
    <span class="kd">var</span> <span class="nx">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// current flags</span>
    <span class="kd">var</span> <span class="nx">code</span><span class="p">;</span>   <span class="c1">// the code to send</span>
    <span class="kd">var</span> <span class="nx">extra</span><span class="p">;</span>    <span class="c1">// number of extra bits to send</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">zip_last_lit</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">do</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">((</span><span class="nx">lx</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nx">flag</span> <span class="o">=</span> <span class="nx">zip_flag_buf</span><span class="p">[</span><span class="nx">fx</span><span class="o">++</span><span class="p">];</span>
  <span class="nx">lc</span> <span class="o">=</span> <span class="nx">zip_l_buf</span><span class="p">[</span><span class="nx">lx</span><span class="o">++</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
  <span class="k">if</span><span class="p">((</span><span class="nx">flag</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">zip_SEND_CODE</span><span class="p">(</span><span class="nx">lc</span><span class="p">,</span> <span class="nx">ltree</span><span class="p">);</span> <span class="cm">/* send a literal byte */</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Tracecv(isgraph(lc), (stderr," '%c' ", lc));</p></div></div><div class="code"><div class="wrapper">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Here, lc is the match length - MIN_MATCH</p></div></div><div class="code"><div class="wrapper">      <span class="nx">code</span> <span class="o">=</span> <span class="nx">zip_length_code</span><span class="p">[</span><span class="nx">lc</span><span class="p">];</span>
      <span class="nx">zip_SEND_CODE</span><span class="p">(</span><span class="nx">code</span><span class="o">+</span><span class="nx">zip_LITERALS</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">ltree</span><span class="p">);</span> <span class="c1">// send the length code</span>
      <span class="nx">extra</span> <span class="o">=</span> <span class="nx">zip_extra_lbits</span><span class="p">[</span><span class="nx">code</span><span class="p">];</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">extra</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">lc</span> <span class="o">-=</span> <span class="nx">zip_base_length</span><span class="p">[</span><span class="nx">code</span><span class="p">];</span>
    <span class="nx">zip_send_bits</span><span class="p">(</span><span class="nx">lc</span><span class="p">,</span> <span class="nx">extra</span><span class="p">);</span> <span class="c1">// send the extra length bits</span>
      <span class="p">}</span>
      <span class="nx">dist</span> <span class="o">=</span> <span class="nx">zip_d_buf</span><span class="p">[</span><span class="nx">dx</span><span class="o">++</span><span class="p">];</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Here, dist is the match distance - 1</p></div></div><div class="code"><div class="wrapper">      <span class="nx">code</span> <span class="o">=</span> <span class="nx">zip_D_CODE</span><span class="p">(</span><span class="nx">dist</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Assert (code &lt; D<em>CODES, "bad d</em>code");</p></div></div><div class="code"><div class="wrapper">      <span class="nx">zip_SEND_CODE</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">dtree</span><span class="p">);</span>   <span class="c1">// send the distance code</span>
      <span class="nx">extra</span> <span class="o">=</span> <span class="nx">zip_extra_dbits</span><span class="p">[</span><span class="nx">code</span><span class="p">];</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">extra</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dist</span> <span class="o">-=</span> <span class="nx">zip_base_dist</span><span class="p">[</span><span class="nx">code</span><span class="p">];</span>
    <span class="nx">zip_send_bits</span><span class="p">(</span><span class="nx">dist</span><span class="p">,</span> <span class="nx">extra</span><span class="p">);</span>   <span class="c1">// send the extra distance bits</span>
      <span class="p">}</span>
  <span class="p">}</span> <span class="c1">// literal or match pair ?</span>
  <span class="nx">flag</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="nx">lx</span> <span class="o">&lt;</span> <span class="nx">zip_last_lit</span><span class="p">);</span>

    <span class="nx">zip_SEND_CODE</span><span class="p">(</span><span class="nx">zip_END_BLOCK</span><span class="p">,</span> <span class="nx">ltree</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Send a value on a given number of bits.</span>
<span class="cm"> * IN assertion: length &lt;= 16 and value fits in length bits.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_Buf_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="c1">// bit size of bi_buf</span>
<span class="kd">var</span> <span class="nx">zip_send_bits</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span>
  <span class="nx">value</span><span class="p">,</span>  <span class="c1">// value to send</span>
  <span class="nx">length</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// number of bits</span>
    <span class="cm">/* If not enough room in bi_buf, use (valid) bits from bi_buf and</span>
<span class="cm">     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))</span>
<span class="cm">     * unused bits in value.</span>
<span class="cm">     */</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_bi_valid</span> <span class="o">&gt;</span> <span class="nx">zip_Buf_size</span> <span class="o">-</span> <span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_bi_buf</span> <span class="o">|=</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&lt;&lt;</span> <span class="nx">zip_bi_valid</span><span class="p">);</span>
  <span class="nx">zip_put_short</span><span class="p">(</span><span class="nx">zip_bi_buf</span><span class="p">);</span>
  <span class="nx">zip_bi_buf</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nx">zip_Buf_size</span> <span class="o">-</span> <span class="nx">zip_bi_valid</span><span class="p">));</span>
  <span class="nx">zip_bi_valid</span> <span class="o">+=</span> <span class="nx">length</span> <span class="o">-</span> <span class="nx">zip_Buf_size</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">zip_bi_buf</span> <span class="o">|=</span> <span class="nx">value</span> <span class="o">&lt;&lt;</span> <span class="nx">zip_bi_valid</span><span class="p">;</span>
  <span class="nx">zip_bi_valid</span> <span class="o">+=</span> <span class="nx">length</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Reverse the first len bits of a code, using straightforward code (a faster</span>
<span class="cm"> * method would use a table)</span>
<span class="cm"> * IN assertion: 1 &lt;= len &lt;= 15</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_bi_reverse</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span>
  <span class="nx">code</span><span class="p">,</span> <span class="c1">// the value to invert</span>
  <span class="nx">len</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// its bit length</span>
    <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
  <span class="nx">res</span> <span class="o">|=</span> <span class="nx">code</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">code</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">res</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="nx">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">res</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ==========================================================================</span>
<span class="cm"> * Write out any remaining bits in an incomplete byte.</span>
<span class="cm"> */</span>
<span class="kd">var</span> <span class="nx">zip_bi_windup</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_bi_valid</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_put_short</span><span class="p">(</span><span class="nx">zip_bi_buf</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">zip_bi_valid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_put_byte</span><span class="p">(</span><span class="nx">zip_bi_buf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">zip_bi_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_bi_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_qoutbuf</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_outcnt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">q</span><span class="p">,</span> <span class="nx">i</span><span class="p">;</span>
  <span class="nx">q</span> <span class="o">=</span> <span class="nx">zip_new_queue</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">zip_qhead</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
      <span class="nx">zip_qhead</span> <span class="o">=</span> <span class="nx">zip_qtail</span> <span class="o">=</span> <span class="nx">q</span><span class="p">;</span>
  <span class="k">else</span>
      <span class="nx">zip_qtail</span> <span class="o">=</span> <span class="nx">zip_qtail</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">q</span><span class="p">;</span>
  <span class="nx">q</span><span class="p">.</span><span class="nx">len</span> <span class="o">=</span> <span class="nx">zip_outcnt</span> <span class="o">-</span> <span class="nx">zip_outoff</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><pre><code> System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);
</code></pre></div></div><div class="code"><div class="wrapper">  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">q</span><span class="p">.</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">q</span><span class="p">.</span><span class="nx">ptr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_outbuf</span><span class="p">[</span><span class="nx">zip_outoff</span> <span class="o">+</span> <span class="nx">i</span><span class="p">];</span>
  <span class="nx">zip_outcnt</span> <span class="o">=</span> <span class="nx">zip_outoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_deflate</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">level</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">;</span>

    <span class="nx">zip_deflate_data</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="nx">zip_deflate_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">level</span> <span class="o">==</span> <span class="s2">&quot;undefined&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">level</span> <span class="o">=</span> <span class="nx">zip_DEFAULT_LEVEL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">zip_deflate_start</span><span class="p">(</span><span class="nx">level</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">buff</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">aout</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">while</span> <span class="p">((</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">zip_deflate_internal</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">buff</span><span class="p">.</span><span class="nx">length</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
       <span class="nx">aout</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="nx">zip_deflate_data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// G.C.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">aout</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">return</span> <span class="nx">zip_deflate</span><span class="p">;</span>
<span class="p">})();</span>






<span class="cm">/*</span>
<span class="cm"> * $Id: rawinflate.js,v 0.2 2009/03/01 18:32:24 dankogai Exp $</span>
<span class="cm"> *</span>
<span class="cm"> * original:</span>
<span class="cm"> * http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt</span>
<span class="cm"> */</span>

<span class="kd">var</span> <span class="nx">Inflate</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(){</span>

<span class="cm">/* Copyright (C) 1999 Masanao Izumo &lt;iz@onicos.co.jp&gt;</span>
<span class="cm"> * Version: 1.0.0.1</span>
<span class="cm"> * LastModified: Dec 25 1999</span>
<span class="cm"> */</span>

<span class="cm">/* Interface:</span>
<span class="cm"> * data = zip_inflate(src);</span>
<span class="cm"> */</span>

<span class="cm">/* constant parameters */</span>
<span class="kd">var</span> <span class="nx">zip_WSIZE</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>    <span class="c1">// Sliding Window size</span>
<span class="kd">var</span> <span class="nx">zip_STORED_BLOCK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_STATIC_TREES</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_DYN_TREES</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="cm">/* for inflate */</span>
<span class="kd">var</span> <span class="nx">zip_lbits</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>    <span class="c1">// bits in base literal/length lookup table</span>
<span class="kd">var</span> <span class="nx">zip_dbits</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>    <span class="c1">// bits in base distance lookup table</span>
<span class="kd">var</span> <span class="nx">zip_INBUFSIZ</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span> <span class="c1">// Input buffer size</span>
<span class="kd">var</span> <span class="nx">zip_INBUF_EXTRA</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span> <span class="c1">// Extra buffer</span>

<span class="cm">/* variables (inflate) */</span>
<span class="kd">var</span> <span class="nx">zip_slide</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_wp</span><span class="p">;</span>     <span class="c1">// current position in slide</span>
<span class="kd">var</span> <span class="nx">zip_fixed_tl</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>  <span class="c1">// inflate static</span>
<span class="kd">var</span> <span class="nx">zip_fixed_td</span><span class="p">;</span>   <span class="c1">// inflate static</span>
<span class="kd">var</span> <span class="nx">zip_fixed_bl</span><span class="p">,</span> <span class="nx">fixed_bd</span><span class="p">;</span> <span class="c1">// inflate static</span>
<span class="kd">var</span> <span class="nx">zip_bit_buf</span><span class="p">;</span>    <span class="c1">// bit buffer</span>
<span class="kd">var</span> <span class="nx">zip_bit_len</span><span class="p">;</span>    <span class="c1">// bits in bit buffer</span>
<span class="kd">var</span> <span class="nx">zip_method</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_eof</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_copy_leng</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_copy_dist</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_tl</span><span class="p">,</span> <span class="nx">zip_td</span><span class="p">;</span> <span class="c1">// literal/length and distance decoder tables</span>
<span class="kd">var</span> <span class="nx">zip_bl</span><span class="p">,</span> <span class="nx">zip_bd</span><span class="p">;</span> <span class="c1">// number of bits decoded by tl and td</span>

<span class="kd">var</span> <span class="nx">zip_inflate_data</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">zip_inflate_pos</span><span class="p">;</span>


<span class="cm">/* constant tables (inflate) */</span>
<span class="kd">var</span> <span class="nx">zip_MASK_BITS</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span>
    <span class="mh">0x0000</span><span class="p">,</span>
    <span class="mh">0x0001</span><span class="p">,</span> <span class="mh">0x0003</span><span class="p">,</span> <span class="mh">0x0007</span><span class="p">,</span> <span class="mh">0x000f</span><span class="p">,</span> <span class="mh">0x001f</span><span class="p">,</span> <span class="mh">0x003f</span><span class="p">,</span> <span class="mh">0x007f</span><span class="p">,</span> <span class="mh">0x00ff</span><span class="p">,</span>
    <span class="mh">0x01ff</span><span class="p">,</span> <span class="mh">0x03ff</span><span class="p">,</span> <span class="mh">0x07ff</span><span class="p">,</span> <span class="mh">0x0fff</span><span class="p">,</span> <span class="mh">0x1fff</span><span class="p">,</span> <span class="mh">0x3fff</span><span class="p">,</span> <span class="mh">0x7fff</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Tables for deflate from PKZIP's appnote.txt.</p></div></div><div class="code"><div class="wrapper"><span class="kd">var</span> <span class="nx">zip_cplens</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span> <span class="c1">// Copy lengths for literal codes 257..285</span>
    <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span>
    <span class="mi">35</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">115</span><span class="p">,</span> <span class="mi">131</span><span class="p">,</span> <span class="mi">163</span><span class="p">,</span> <span class="mi">195</span><span class="p">,</span> <span class="mi">227</span><span class="p">,</span> <span class="mi">258</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cm">/* note: see note #13 above about the 258 in this list. */</span>
<span class="kd">var</span> <span class="nx">zip_cplext</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span> <span class="c1">// Extra bits for literal codes 257..285</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">99</span><span class="p">);</span> <span class="c1">// 99==invalid</span>
<span class="kd">var</span> <span class="nx">zip_cpdist</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span> <span class="c1">// Copy offsets for distance codes 0..29</span>
    <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">129</span><span class="p">,</span> <span class="mi">193</span><span class="p">,</span>
    <span class="mi">257</span><span class="p">,</span> <span class="mi">385</span><span class="p">,</span> <span class="mi">513</span><span class="p">,</span> <span class="mi">769</span><span class="p">,</span> <span class="mi">1025</span><span class="p">,</span> <span class="mi">1537</span><span class="p">,</span> <span class="mi">2049</span><span class="p">,</span> <span class="mi">3073</span><span class="p">,</span> <span class="mi">4097</span><span class="p">,</span> <span class="mi">6145</span><span class="p">,</span>
    <span class="mi">8193</span><span class="p">,</span> <span class="mi">12289</span><span class="p">,</span> <span class="mi">16385</span><span class="p">,</span> <span class="mi">24577</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">zip_cpdext</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span> <span class="c1">// Extra bits for distance codes</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
    <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
    <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">zip_border</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span>  <span class="c1">// Order of the bit length code lengths</span>
    <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
<span class="cm">/* objects (inflate) */</span>

<span class="kd">var</span> <span class="nx">zip_HuftList</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">list</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_HuftNode</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// number of extra bits or operation</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// number of bits in this code or subcode</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>union</p></div></div><div class="code"><div class="wrapper">    <span class="k">this</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// literal, length base, or distance base</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">t</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// (zip_HuftNode) pointer to next level of table</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_HuftBuild</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="c1">// code lengths in bits (all assumed &lt;= BMAX)</span>
           <span class="nx">n</span><span class="p">,</span> <span class="c1">// number of codes (assumed &lt;= N_MAX)</span>
           <span class="nx">s</span><span class="p">,</span> <span class="c1">// number of simple-valued codes (0..s-1)</span>
           <span class="nx">d</span><span class="p">,</span> <span class="c1">// list of base values for non-simple codes</span>
           <span class="nx">e</span><span class="p">,</span> <span class="c1">// list of extra bits for non-simple codes</span>
           <span class="nx">mm</span> <span class="c1">// maximum lookup bits</span>
       <span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">BMAX</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>   <span class="c1">// maximum bit length of any code</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">N_MAX</span> <span class="o">=</span> <span class="mi">288</span><span class="p">;</span> <span class="c1">// maximum number of codes in any set</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 0: success, 1: incomplete table, 2: bad input</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// (zip_HuftList) starting table</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// maximum lookup bits, returns actual</span>

<span class="cm">/* Given a list of code lengths and a maximum table size, make a set of</span>
<span class="cm">   tables to decode that set of codes.  Return zero on success, one if</span>
<span class="cm">   the given code set is incomplete (the tables are still built in this</span>
<span class="cm">   case), two if the input is invalid (all zero length codes or an</span>
<span class="cm">   oversubscribed set of lengths), and three if not enough memory.</span>
<span class="cm">   The code with value 256 is special, and the tables are constructed</span>
<span class="cm">   so that no bits beyond that code are fetched when that code is</span>
<span class="cm">   decoded. */</span>
    <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span>      <span class="c1">// counter for codes of length k</span>
  <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">BMAX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// bit length count table</span>
  <span class="kd">var</span> <span class="nx">el</span><span class="p">;</span>     <span class="c1">// length of EOB code (value 256)</span>
  <span class="kd">var</span> <span class="nx">f</span><span class="p">;</span>      <span class="c1">// i repeats in table every f entries</span>
  <span class="kd">var</span> <span class="nx">g</span><span class="p">;</span>      <span class="c1">// maximum code length</span>
  <span class="kd">var</span> <span class="nx">h</span><span class="p">;</span>      <span class="c1">// table level</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>      <span class="c1">// counter, current code</span>
  <span class="kd">var</span> <span class="nx">j</span><span class="p">;</span>      <span class="c1">// counter</span>
  <span class="kd">var</span> <span class="nx">k</span><span class="p">;</span>      <span class="c1">// number of bits in current code</span>
  <span class="kd">var</span> <span class="nx">lx</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">BMAX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// stack of bits per table</span>
  <span class="kd">var</span> <span class="nx">p</span><span class="p">;</span>      <span class="c1">// pointer into c[], b[], or v[]</span>
  <span class="kd">var</span> <span class="nx">pidx</span><span class="p">;</span>   <span class="c1">// index of p</span>
  <span class="kd">var</span> <span class="nx">q</span><span class="p">;</span>      <span class="c1">// (zip_HuftNode) points to current table</span>
  <span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_HuftNode</span><span class="p">();</span> <span class="c1">// table entry for structure assignment</span>
  <span class="kd">var</span> <span class="nx">u</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">BMAX</span><span class="p">);</span> <span class="c1">// zip_HuftNode[BMAX][]  table stack</span>
  <span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">N_MAX</span><span class="p">);</span> <span class="c1">// values in order of bit length</span>
  <span class="kd">var</span> <span class="nx">w</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">BMAX</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="c1">// bit offsets, then code stack</span>
  <span class="kd">var</span> <span class="nx">xp</span><span class="p">;</span>     <span class="c1">// pointer into x or c</span>
  <span class="kd">var</span> <span class="nx">y</span><span class="p">;</span>      <span class="c1">// number of dummy codes added</span>
  <span class="kd">var</span> <span class="nx">z</span><span class="p">;</span>      <span class="c1">// number of entries in current table</span>
  <span class="kd">var</span> <span class="nx">o</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">tail</span><span class="p">;</span>   <span class="c1">// (zip_HuftList)</span>

  <span class="nx">tail</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">c</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">lx</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">lx</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">u</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">u</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">x</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Generate counts for each bit length</p></div></div><div class="code"><div class="wrapper">  <span class="nx">el</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">&gt;</span> <span class="mi">256</span> <span class="o">?</span> <span class="nx">b</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">BMAX</span><span class="p">;</span> <span class="c1">// set length of EOB code, if any</span>
  <span class="nx">p</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span> <span class="nx">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">i</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
      <span class="nx">c</span><span class="p">[</span><span class="nx">p</span><span class="p">[</span><span class="nx">pidx</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span> <span class="c1">// assume all entries &lt;= BMAX</span>
      <span class="nx">pidx</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// null input--all zero length codes</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Find minimum and maximum length, bound *m by those</p></div></div><div class="code"><div class="wrapper">  <span class="k">for</span><span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">BMAX</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">c</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="nx">k</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>      <span class="c1">// minimum code length</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">mm</span> <span class="o">&lt;</span> <span class="nx">j</span><span class="p">)</span>
      <span class="nx">mm</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">BMAX</span><span class="p">;</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">c</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="nx">g</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>      <span class="c1">// maximum code length</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">mm</span> <span class="o">&gt;</span> <span class="nx">i</span><span class="p">)</span>
      <span class="nx">mm</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Adjust last length count to fill out codes, if needed</p></div></div><div class="code"><div class="wrapper">  <span class="k">for</span><span class="p">(</span><span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">,</span> <span class="nx">y</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">if</span><span class="p">((</span><span class="nx">y</span> <span class="o">-=</span> <span class="nx">c</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// bad input: more codes than bits</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="nx">mm</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="k">if</span><span class="p">((</span><span class="nx">y</span> <span class="o">-=</span> <span class="nx">c</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="nx">mm</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">c</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">y</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Generate starting offsets into the value table for each length</p></div></div><div class="code"><div class="wrapper">  <span class="nx">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">p</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span>
  <span class="nx">pidx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">xp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="o">--</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>    <span class="c1">// note that i == g from above</span>
      <span class="nx">x</span><span class="p">[</span><span class="nx">xp</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">j</span> <span class="o">+=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">pidx</span><span class="o">++</span><span class="p">]);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Make a table of values in order of bit lengths</p></div></div><div class="code"><div class="wrapper">  <span class="nx">p</span> <span class="o">=</span> <span class="nx">b</span><span class="p">;</span> <span class="nx">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">((</span><span class="nx">j</span> <span class="o">=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">pidx</span><span class="o">++</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">v</span><span class="p">[</span><span class="nx">x</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="o">++</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">);</span>
  <span class="nx">n</span> <span class="o">=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">g</span><span class="p">];</span>     <span class="c1">// set n to length of v</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Generate the Huffman codes and for each, make the table entries</p></div></div><div class="code"><div class="wrapper">  <span class="nx">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// first Huffman code is zero</span>
  <span class="nx">p</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span> <span class="nx">pidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// grab values in bit order</span>
  <span class="nx">h</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>     <span class="c1">// no tables yet--level -1</span>
  <span class="nx">w</span> <span class="o">=</span> <span class="nx">lx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// no bits decoded yet</span>
  <span class="nx">q</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>     <span class="c1">// ditto</span>
  <span class="nx">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// ditto</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>go through the bit lengths (k already is bits in shortest code)</p></div></div><div class="code"><div class="wrapper">  <span class="k">for</span><span class="p">(;</span> <span class="nx">k</span> <span class="o">&lt;=</span> <span class="nx">g</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">a</span> <span class="o">=</span> <span class="nx">c</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span>
      <span class="k">while</span><span class="p">(</span><span class="nx">a</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>here i is the Huffman code of length k bits for value p[pidx]
make tables up to required level</p></div></div><div class="code"><div class="wrapper">    <span class="k">while</span><span class="p">(</span><span class="nx">k</span> <span class="o">&gt;</span> <span class="nx">w</span> <span class="o">+</span> <span class="nx">lx</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="nx">h</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">w</span> <span class="o">+=</span> <span class="nx">lx</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="nx">h</span><span class="p">];</span> <span class="c1">// add bits already decoded</span>
        <span class="nx">h</span><span class="o">++</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>compute minimum size table less than or equal to *m bits</p></div></div><div class="code"><div class="wrapper">        <span class="nx">z</span> <span class="o">=</span> <span class="p">(</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">g</span> <span class="o">-</span> <span class="nx">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nx">mm</span> <span class="o">?</span> <span class="nx">mm</span> <span class="o">:</span> <span class="nx">z</span><span class="p">;</span> <span class="c1">// upper limit</span>
        <span class="k">if</span><span class="p">((</span><span class="nx">f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="nx">k</span> <span class="o">-</span> <span class="nx">w</span><span class="p">))</span> <span class="o">&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// try a k-w bit table</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>too few codes for k-w bit table</p></div></div><div class="code"><div class="wrapper">      <span class="nx">f</span> <span class="o">-=</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// deduct codes from patterns left</span>
      <span class="nx">xp</span> <span class="o">=</span> <span class="nx">k</span><span class="p">;</span>
      <span class="k">while</span><span class="p">(</span><span class="o">++</span><span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// try smaller tables up to z bits</span>
          <span class="k">if</span><span class="p">((</span><span class="nx">f</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nx">c</span><span class="p">[</span><span class="o">++</span><span class="nx">xp</span><span class="p">])</span>
        <span class="k">break</span><span class="p">;</span>  <span class="c1">// enough codes to use up j bits</span>
          <span class="nx">f</span> <span class="o">-=</span> <span class="nx">c</span><span class="p">[</span><span class="nx">xp</span><span class="p">];</span> <span class="c1">// else deduct codes from patterns</span>
      <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">w</span> <span class="o">+</span> <span class="nx">j</span> <span class="o">&gt;</span> <span class="nx">el</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span> <span class="o">&lt;</span> <span class="nx">el</span><span class="p">)</span>
      <span class="nx">j</span> <span class="o">=</span> <span class="nx">el</span> <span class="o">-</span> <span class="nx">w</span><span class="p">;</span> <span class="c1">// make EOB code end at table</span>
        <span class="nx">z</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="c1">// table entries for j-bit table</span>
        <span class="nx">lx</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="nx">h</span><span class="p">]</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span> <span class="c1">// set table size in stack</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>allocate and link in new table</p></div></div><div class="code"><div class="wrapper">        <span class="nx">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">z</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="nx">o</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">o</span> <span class="o">&lt;</span> <span class="nx">z</span><span class="p">;</span> <span class="nx">o</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">q</span><span class="p">[</span><span class="nx">o</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_HuftNode</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="nx">tail</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
      <span class="nx">tail</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_HuftList</span><span class="p">();</span>
        <span class="k">else</span>
      <span class="nx">tail</span> <span class="o">=</span> <span class="nx">tail</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_HuftList</span><span class="p">();</span>
        <span class="nx">tail</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="nx">tail</span><span class="p">.</span><span class="nx">list</span> <span class="o">=</span> <span class="nx">q</span><span class="p">;</span>
        <span class="nx">u</span><span class="p">[</span><span class="nx">h</span><span class="p">]</span> <span class="o">=</span> <span class="nx">q</span><span class="p">;</span> <span class="c1">// table starts after link</span>

        <span class="cm">/* connect to last table, if there is one */</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">x</span><span class="p">[</span><span class="nx">h</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>   <span class="c1">// save pattern for backing up</span>
      <span class="nx">r</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">lx</span><span class="p">[</span><span class="nx">h</span><span class="p">];</span>  <span class="c1">// bits to dump before this table</span>
      <span class="nx">r</span><span class="p">.</span><span class="nx">e</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">+</span> <span class="nx">j</span><span class="p">;</span> <span class="c1">// bits in this table</span>
      <span class="nx">r</span><span class="p">.</span><span class="nx">t</span> <span class="o">=</span> <span class="nx">q</span><span class="p">;</span>    <span class="c1">// pointer to this table</span>
      <span class="nx">j</span> <span class="o">=</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">w</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nx">w</span> <span class="o">-</span> <span class="nx">lx</span><span class="p">[</span><span class="nx">h</span><span class="p">]);</span>
      <span class="nx">u</span><span class="p">[</span><span class="nx">h</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">].</span><span class="nx">e</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">e</span><span class="p">;</span>
      <span class="nx">u</span><span class="p">[</span><span class="nx">h</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">].</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
      <span class="nx">u</span><span class="p">[</span><span class="nx">h</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">].</span><span class="nx">n</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
      <span class="nx">u</span><span class="p">[</span><span class="nx">h</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">].</span><span class="nx">t</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">t</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>set up table entry in r</p></div></div><div class="code"><div class="wrapper">    <span class="nx">r</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">k</span> <span class="o">-</span> <span class="nx">w</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">pidx</span> <span class="o">&gt;=</span> <span class="nx">n</span><span class="p">)</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">e</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>   <span class="c1">// out of values--invalid code</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">p</span><span class="p">[</span><span class="nx">pidx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">e</span> <span class="o">=</span> <span class="p">(</span><span class="nx">p</span><span class="p">[</span><span class="nx">pidx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">256</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">15</span><span class="p">);</span> <span class="c1">// 256 is end-of-block code</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="nx">p</span><span class="p">[</span><span class="nx">pidx</span><span class="o">++</span><span class="p">];</span>  <span class="c1">// simple code is just the value</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">e</span> <span class="o">=</span> <span class="nx">e</span><span class="p">[</span><span class="nx">p</span><span class="p">[</span><span class="nx">pidx</span><span class="p">]</span> <span class="o">-</span> <span class="nx">s</span><span class="p">];</span> <span class="c1">// non-simple--look up in lists</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">n</span> <span class="o">=</span> <span class="nx">d</span><span class="p">[</span><span class="nx">p</span><span class="p">[</span><span class="nx">pidx</span><span class="o">++</span><span class="p">]</span> <span class="o">-</span> <span class="nx">s</span><span class="p">];</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>fill code-like entries with r //</p></div></div><div class="code"><div class="wrapper">    <span class="nx">f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">k</span> <span class="o">-</span> <span class="nx">w</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">&gt;&gt;</span> <span class="nx">w</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">z</span><span class="p">;</span> <span class="nx">j</span> <span class="o">+=</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">q</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">e</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">e</span><span class="p">;</span>
        <span class="nx">q</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
        <span class="nx">q</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">n</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
        <span class="nx">q</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">t</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">t</span><span class="p">;</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>backwards increment the k-bit code i</p></div></div><div class="code"><div class="wrapper">    <span class="k">for</span><span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&amp;</span> <span class="nx">j</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nx">i</span> <span class="o">^=</span> <span class="nx">j</span><span class="p">;</span>
    <span class="nx">i</span> <span class="o">^=</span> <span class="nx">j</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>backup over finished tables</p></div></div><div class="code"><div class="wrapper">    <span class="k">while</span><span class="p">((</span><span class="nx">i</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">w</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">h</span><span class="p">])</span> <span class="p">{</span>
        <span class="nx">w</span> <span class="o">-=</span> <span class="nx">lx</span><span class="p">[</span><span class="nx">h</span><span class="p">];</span>   <span class="c1">// don&#39;t need to update q</span>
        <span class="nx">h</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/* return actual size of base table */</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="nx">lx</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="cm">/* Return true (1) if we were given an incomplete table */</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="p">((</span><span class="nx">y</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">g</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span> <span class="cm">/* end of constructor */</span>
<span class="p">}</span>


<span class="cm">/* routines (inflate) */</span>

<span class="kd">var</span> <span class="nx">zip_GET_BYTE</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_inflate_data</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="nx">zip_inflate_pos</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">zip_inflate_data</span><span class="p">[</span><span class="nx">zip_inflate_pos</span><span class="o">++</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_NEEDBITS</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">zip_bit_len</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_bit_buf</span> <span class="o">|=</span> <span class="nx">zip_GET_BYTE</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nx">zip_bit_len</span><span class="p">;</span>
  <span class="nx">zip_bit_len</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_GETBITS</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">zip_bit_buf</span> <span class="o">&amp;</span> <span class="nx">zip_MASK_BITS</span><span class="p">[</span><span class="nx">n</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_DUMPBITS</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">zip_bit_buf</span> <span class="o">&gt;&gt;=</span> <span class="nx">n</span><span class="p">;</span>
    <span class="nx">zip_bit_len</span> <span class="o">-=</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_inflate_codes</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* inflate (decompress) the codes in a deflated (compressed) block.</span>
<span class="cm">       Return an error code or zero if it all goes ok. */</span>
    <span class="kd">var</span> <span class="nx">e</span><span class="p">;</span>    <span class="c1">// table entry flag/number of extra bits</span>
    <span class="kd">var</span> <span class="nx">t</span><span class="p">;</span>    <span class="c1">// (zip_HuftNode) pointer to table entry</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>inflate the coded data</p></div></div><div class="code"><div class="wrapper">    <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>     <span class="c1">// do until end of block</span>
  <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="nx">zip_bl</span><span class="p">);</span>
  <span class="nx">t</span> <span class="o">=</span> <span class="nx">zip_tl</span><span class="p">.</span><span class="nx">list</span><span class="p">[</span><span class="nx">zip_GETBITS</span><span class="p">(</span><span class="nx">zip_bl</span><span class="p">)];</span>
  <span class="nx">e</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">e</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="nx">e</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">e</span> <span class="o">==</span> <span class="mi">99</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">b</span><span class="p">);</span>
      <span class="nx">e</span> <span class="o">-=</span> <span class="mi">16</span><span class="p">;</span>
      <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
      <span class="nx">t</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">zip_GETBITS</span><span class="p">(</span><span class="nx">e</span><span class="p">)];</span>
      <span class="nx">e</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">e</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">b</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="nx">e</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// then it&#39;s a literal</span>
      <span class="nx">zip_wp</span> <span class="o">&amp;=</span> <span class="nx">zip_WSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">buff</span><span class="p">[</span><span class="nx">off</span> <span class="o">+</span> <span class="nx">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_slide</span><span class="p">[</span><span class="nx">zip_wp</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="nx">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">size</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
  <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>exit if end of block</p></div></div><div class="code"><div class="wrapper">  <span class="k">if</span><span class="p">(</span><span class="nx">e</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>it's an EOB or a length</p></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>get length of block to copy</p></div></div><div class="code"><div class="wrapper">  <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
  <span class="nx">zip_copy_leng</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">n</span> <span class="o">+</span> <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
  <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>decode distance of block to copy</p></div></div><div class="code"><div class="wrapper">  <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="nx">zip_bd</span><span class="p">);</span>
  <span class="nx">t</span> <span class="o">=</span> <span class="nx">zip_td</span><span class="p">.</span><span class="nx">list</span><span class="p">[</span><span class="nx">zip_GETBITS</span><span class="p">(</span><span class="nx">zip_bd</span><span class="p">)];</span>
  <span class="nx">e</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">e</span><span class="p">;</span>

  <span class="k">while</span><span class="p">(</span><span class="nx">e</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">e</span> <span class="o">==</span> <span class="mi">99</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">b</span><span class="p">);</span>
      <span class="nx">e</span> <span class="o">-=</span> <span class="mi">16</span><span class="p">;</span>
      <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
      <span class="nx">t</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">t</span><span class="p">[</span><span class="nx">zip_GETBITS</span><span class="p">(</span><span class="nx">e</span><span class="p">)];</span>
      <span class="nx">e</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">e</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">b</span><span class="p">);</span>
  <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
  <span class="nx">zip_copy_dist</span> <span class="o">=</span> <span class="nx">zip_wp</span> <span class="o">-</span> <span class="nx">t</span><span class="p">.</span><span class="nx">n</span> <span class="o">-</span> <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
  <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>do the copy</p></div></div><div class="code"><div class="wrapper">  <span class="k">while</span><span class="p">(</span><span class="nx">zip_copy_leng</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">zip_copy_leng</span><span class="o">--</span><span class="p">;</span>
      <span class="nx">zip_copy_dist</span> <span class="o">&amp;=</span> <span class="nx">zip_WSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">zip_wp</span> <span class="o">&amp;=</span> <span class="nx">zip_WSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">buff</span><span class="p">[</span><span class="nx">off</span> <span class="o">+</span> <span class="nx">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_slide</span><span class="p">[</span><span class="nx">zip_wp</span><span class="o">++</span><span class="p">]</span>
    <span class="o">=</span> <span class="nx">zip_slide</span><span class="p">[</span><span class="nx">zip_copy_dist</span><span class="o">++</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="nx">size</span><span class="p">)</span>
      <span class="k">return</span> <span class="nx">size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">zip_method</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// done</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_inflate_stored</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* &quot;decompress&quot; an inflated type 0 (stored) block. */</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>go to byte boundary</p></div></div><div class="code"><div class="wrapper">    <span class="nx">n</span> <span class="o">=</span> <span class="nx">zip_bit_len</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
    <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>get the length and its complement</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="nx">n</span> <span class="o">=</span> <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">!=</span> <span class="p">((</span><span class="o">~</span><span class="nx">zip_bit_buf</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">))</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>      <span class="c1">// error in compressed data</span>
    <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>read and output the compressed data</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_copy_leng</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>

    <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">zip_copy_leng</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_copy_leng</span><span class="o">--</span><span class="p">;</span>
  <span class="nx">zip_wp</span> <span class="o">&amp;=</span> <span class="nx">zip_WSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
  <span class="nx">buff</span><span class="p">[</span><span class="nx">off</span> <span class="o">+</span> <span class="nx">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_slide</span><span class="p">[</span><span class="nx">zip_wp</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
      <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
  <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">zip_copy_leng</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nx">zip_method</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// done</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_inflate_fixed</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* decompress an inflated type 1 (fixed Huffman codes) block.  We should</span>
<span class="cm">       either replace this with a custom decoder, or at least precompute the</span>
<span class="cm">       Huffman tables. */</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>if first time, set up tables for fixed blocks</p></div></div><div class="code"><div class="wrapper">    <span class="k">if</span><span class="p">(</span><span class="nx">zip_fixed_tl</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>      <span class="c1">// temporary variable</span>
  <span class="kd">var</span> <span class="nx">l</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">288</span><span class="p">);</span> <span class="c1">// length list for huft_build</span>
  <span class="kd">var</span> <span class="nx">h</span><span class="p">;</span>  <span class="c1">// zip_HuftBuild</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>literal table</p></div></div><div class="code"><div class="wrapper">  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">144</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">l</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">l</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">280</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">l</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">288</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// make a complete, but wrong code set</span>
      <span class="nx">l</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="nx">zip_fixed_bl</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

  <span class="nx">h</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_HuftBuild</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="mi">288</span><span class="p">,</span> <span class="mi">257</span><span class="p">,</span> <span class="nx">zip_cplens</span><span class="p">,</span> <span class="nx">zip_cplext</span><span class="p">,</span>
            <span class="nx">zip_fixed_bl</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;HufBuild error: &quot;</span><span class="o">+</span><span class="nx">h</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">zip_fixed_tl</span> <span class="o">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">root</span><span class="p">;</span>
  <span class="nx">zip_fixed_bl</span> <span class="o">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">m</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>distance table</p></div></div><div class="code"><div class="wrapper">  <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">// make an incomplete code set</span>
      <span class="nx">l</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">zip_fixed_bd</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

  <span class="nx">h</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_HuftBuild</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">zip_cpdist</span><span class="p">,</span> <span class="nx">zip_cpdext</span><span class="p">,</span> <span class="nx">zip_fixed_bd</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">status</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">zip_fixed_tl</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;HufBuild error: &quot;</span><span class="o">+</span><span class="nx">h</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">zip_fixed_td</span> <span class="o">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">root</span><span class="p">;</span>
  <span class="nx">zip_fixed_bd</span> <span class="o">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">m</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">zip_tl</span> <span class="o">=</span> <span class="nx">zip_fixed_tl</span><span class="p">;</span>
    <span class="nx">zip_td</span> <span class="o">=</span> <span class="nx">zip_fixed_td</span><span class="p">;</span>
    <span class="nx">zip_bl</span> <span class="o">=</span> <span class="nx">zip_fixed_bl</span><span class="p">;</span>
    <span class="nx">zip_bd</span> <span class="o">=</span> <span class="nx">zip_fixed_bd</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">zip_inflate_codes</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="nx">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_inflate_dynamic</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>decompress an inflated type 2 (dynamic Huffman codes) block.</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>    <span class="c1">// temporary variables</span>
    <span class="kd">var</span> <span class="nx">j</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">l</span><span class="p">;</span>    <span class="c1">// last length</span>
    <span class="kd">var</span> <span class="nx">n</span><span class="p">;</span>    <span class="c1">// number of lengths to get</span>
    <span class="kd">var</span> <span class="nx">t</span><span class="p">;</span>    <span class="c1">// (zip_HuftNode) literal/length code table</span>
    <span class="kd">var</span> <span class="nx">nb</span><span class="p">;</span>   <span class="c1">// number of bit length codes</span>
    <span class="kd">var</span> <span class="nx">nl</span><span class="p">;</span>   <span class="c1">// number of literal/length codes</span>
    <span class="kd">var</span> <span class="nx">nd</span><span class="p">;</span>   <span class="c1">// number of distance codes</span>
    <span class="kd">var</span> <span class="nx">ll</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">286</span><span class="o">+</span><span class="mi">30</span><span class="p">);</span> <span class="c1">// literal/length and distance code lengths</span>
    <span class="kd">var</span> <span class="nx">h</span><span class="p">;</span>    <span class="c1">// (zip_HuftBuild)</span>

    <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">ll</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
  <span class="nx">ll</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>read in table lengths</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="nx">nl</span> <span class="o">=</span> <span class="mi">257</span> <span class="o">+</span> <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">// number of literal/length codes</span>
    <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="nx">nd</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">// number of distance codes</span>
    <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="nx">nb</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>  <span class="c1">// number of bit length codes</span>
    <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">nl</span> <span class="o">&gt;</span> <span class="mi">286</span> <span class="o">||</span> <span class="nx">nd</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>    <span class="c1">// bad lengths</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>read in bit-length-code lengths</p></div></div><div class="code"><div class="wrapper">    <span class="k">for</span><span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">nb</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
  <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nx">ll</span><span class="p">[</span><span class="nx">zip_border</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">19</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span>
  <span class="nx">ll</span><span class="p">[</span><span class="nx">zip_border</span><span class="p">[</span><span class="nx">j</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>build decoding table for trees--single level, 7 bit lookup</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_bl</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="nx">h</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_HuftBuild</span><span class="p">(</span><span class="nx">ll</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">zip_bl</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// incomplete code set</span>

    <span class="nx">zip_tl</span> <span class="o">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">root</span><span class="p">;</span>
    <span class="nx">zip_bl</span> <span class="o">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">m</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>read in literal and distance code lengths</p></div></div><div class="code"><div class="wrapper">    <span class="nx">n</span> <span class="o">=</span> <span class="nx">nl</span> <span class="o">+</span> <span class="nx">nd</span><span class="p">;</span>
    <span class="nx">i</span> <span class="o">=</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="nx">zip_bl</span><span class="p">);</span>
  <span class="nx">t</span> <span class="o">=</span> <span class="nx">zip_tl</span><span class="p">.</span><span class="nx">list</span><span class="p">[</span><span class="nx">zip_GETBITS</span><span class="p">(</span><span class="nx">zip_bl</span><span class="p">)];</span>
  <span class="nx">j</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
  <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="nx">j</span><span class="p">);</span>
  <span class="nx">j</span> <span class="o">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">n</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>    <span class="c1">// length of code in bits (0..15)</span>
      <span class="nx">ll</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">j</span><span class="p">;</span>  <span class="c1">// save last length in l</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">j</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// repeat last length 3 to 6 times</span>
      <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
      <span class="nx">j</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
      <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">j</span> <span class="o">&gt;</span> <span class="nx">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="k">while</span><span class="p">(</span><span class="nx">j</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">ll</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">l</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">j</span> <span class="o">==</span> <span class="mi">17</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 3 to 10 zero length codes</span>
      <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
      <span class="nx">j</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
      <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">j</span> <span class="o">&gt;</span> <span class="nx">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="k">while</span><span class="p">(</span><span class="nx">j</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">ll</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>    <span class="c1">// j == 18: 11 to 138 zero length codes</span>
      <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
      <span class="nx">j</span> <span class="o">=</span> <span class="mi">11</span> <span class="o">+</span> <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
      <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">j</span> <span class="o">&gt;</span> <span class="nx">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="k">while</span><span class="p">(</span><span class="nx">j</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">ll</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
    <span class="p">}</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>build the decoding tables for literal/length and distance codes</p></div></div><div class="code"><div class="wrapper">    <span class="nx">zip_bl</span> <span class="o">=</span> <span class="nx">zip_lbits</span><span class="p">;</span>
    <span class="nx">h</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_HuftBuild</span><span class="p">(</span><span class="nx">ll</span><span class="p">,</span> <span class="nx">nl</span><span class="p">,</span> <span class="mi">257</span><span class="p">,</span> <span class="nx">zip_cplens</span><span class="p">,</span> <span class="nx">zip_cplext</span><span class="p">,</span> <span class="nx">zip_bl</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_bl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// no literals or lengths</span>
  <span class="nx">h</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>if(h.status == 1);// <strong>incomplete literal tree</strong></p></div></div><div class="code"><div class="wrapper">  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>    <span class="c1">// incomplete code set</span>
    <span class="p">}</span>
    <span class="nx">zip_tl</span> <span class="o">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">root</span><span class="p">;</span>
    <span class="nx">zip_bl</span> <span class="o">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">m</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nd</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
  <span class="nx">ll</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">ll</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">nl</span><span class="p">];</span>
    <span class="nx">zip_bd</span> <span class="o">=</span> <span class="nx">zip_dbits</span><span class="p">;</span>
    <span class="nx">h</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">zip_HuftBuild</span><span class="p">(</span><span class="nx">ll</span><span class="p">,</span> <span class="nx">nd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">zip_cpdist</span><span class="p">,</span> <span class="nx">zip_cpdext</span><span class="p">,</span> <span class="nx">zip_bd</span><span class="p">);</span>
    <span class="nx">zip_td</span> <span class="o">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">root</span><span class="p">;</span>
    <span class="nx">zip_bd</span> <span class="o">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">m</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">zip_bd</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">nl</span> <span class="o">&gt;</span> <span class="mi">257</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// lengths but no distances</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p><strong>incomplete distance tree</strong></p></div></div><div class="code"><div class="wrapper">  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">;</span><span class="c1">// **incomplete distance tree**</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>decompress until an end-of-block code</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="nx">zip_inflate_codes</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="nx">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_inflate_start</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="nx">zip_slide</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
  <span class="nx">zip_slide</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">zip_WSIZE</span><span class="p">);</span>
    <span class="nx">zip_wp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_bit_buf</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_bit_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_method</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="nx">zip_eof</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="nx">zip_copy_leng</span> <span class="o">=</span> <span class="nx">zip_copy_dist</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">zip_tl</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_inflate_internal</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>decompress an inflated entry</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">i</span><span class="p">;</span>

    <span class="nx">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">zip_eof</span> <span class="o">&amp;&amp;</span> <span class="nx">zip_method</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="nx">zip_copy_leng</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">zip_method</span> <span class="o">!=</span> <span class="nx">zip_STORED_BLOCK</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>STATIC<em>TREES or DYN</em>TREES</p></div></div><div class="code"><div class="wrapper">    <span class="k">while</span><span class="p">(</span><span class="nx">zip_copy_leng</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">zip_copy_leng</span><span class="o">--</span><span class="p">;</span>
        <span class="nx">zip_copy_dist</span> <span class="o">&amp;=</span> <span class="nx">zip_WSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">zip_wp</span> <span class="o">&amp;=</span> <span class="nx">zip_WSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">buff</span><span class="p">[</span><span class="nx">off</span> <span class="o">+</span> <span class="nx">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_slide</span><span class="p">[</span><span class="nx">zip_wp</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span>
      <span class="nx">zip_slide</span><span class="p">[</span><span class="nx">zip_copy_dist</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">zip_copy_leng</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">zip_copy_leng</span><span class="o">--</span><span class="p">;</span>
        <span class="nx">zip_wp</span> <span class="o">&amp;=</span> <span class="nx">zip_WSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
        <span class="nx">buff</span><span class="p">[</span><span class="nx">off</span> <span class="o">+</span> <span class="nx">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_slide</span><span class="p">[</span><span class="nx">zip_wp</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
        <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">zip_copy_leng</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="nx">zip_method</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// done</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="nx">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="nx">zip_method</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">zip_eof</span><span class="p">)</span>
    <span class="k">break</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>read in last block bit</p></div></div><div class="code"><div class="wrapper">      <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">zip_GETBITS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">zip_eof</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>read in block type</p></div></div><div class="code"><div class="wrapper">      <span class="nx">zip_NEEDBITS</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
      <span class="nx">zip_method</span> <span class="o">=</span> <span class="nx">zip_GETBITS</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
      <span class="nx">zip_DUMPBITS</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
      <span class="nx">zip_tl</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="nx">zip_copy_leng</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">switch</span><span class="p">(</span><span class="nx">zip_method</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="c1">// zip_STORED_BLOCK</span>
      <span class="nx">i</span> <span class="o">=</span> <span class="nx">zip_inflate_stored</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span> <span class="o">+</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">size</span> <span class="o">-</span> <span class="nx">n</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="c1">// zip_STATIC_TREES</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">zip_tl</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
    <span class="nx">i</span> <span class="o">=</span> <span class="nx">zip_inflate_codes</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span> <span class="o">+</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">size</span> <span class="o">-</span> <span class="nx">n</span><span class="p">);</span>
      <span class="k">else</span>
    <span class="nx">i</span> <span class="o">=</span> <span class="nx">zip_inflate_fixed</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span> <span class="o">+</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">size</span> <span class="o">-</span> <span class="nx">n</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="c1">// zip_DYN_TREES</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">zip_tl</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
    <span class="nx">i</span> <span class="o">=</span> <span class="nx">zip_inflate_codes</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span> <span class="o">+</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">size</span> <span class="o">-</span> <span class="nx">n</span><span class="p">);</span>
      <span class="k">else</span>
    <span class="nx">i</span> <span class="o">=</span> <span class="nx">zip_inflate_dynamic</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="nx">off</span> <span class="o">+</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">size</span> <span class="o">-</span> <span class="nx">n</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span> <span class="c1">// error</span>
      <span class="nx">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="nx">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">zip_eof</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">n</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">zip_inflate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">;</span>
    <span class="nx">zip_inflate_start</span><span class="p">();</span>
    <span class="nx">zip_inflate_data</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="nx">zip_inflate_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kd">var</span> <span class="nx">buff</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kd">var</span> <span class="nx">aout</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">while</span><span class="p">((</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">zip_inflate_internal</span><span class="p">(</span><span class="nx">buff</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">buff</span><span class="p">.</span><span class="nx">length</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">aout</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">buff</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="nx">zip_inflate_data</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// G.C.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">aout</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">return</span> <span class="nx">zip_inflate</span><span class="p">;</span>

<span class="p">})();</span>

<span class="kd">var</span> <span class="nx">adler32</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">MOD_ADLER</span> <span class="o">=</span> <span class="mi">65521</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">+=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">%</span> <span class="nx">MOD_ADLER</span><span class="p">;</span>
    <span class="nx">b</span> <span class="o">=</span> <span class="p">(</span><span class="nx">b</span> <span class="o">+</span> <span class="nx">a</span><span class="p">)</span> <span class="o">%</span> <span class="nx">MOD_ADLER</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">b</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">Compress</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">level</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">calculated_checksum</span> <span class="o">=</span> <span class="nx">adler32</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">deflated_data</span> <span class="o">=</span> <span class="nx">Deflate</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">level</span><span class="p">);</span>
  <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">deflated_data</span><span class="p">.</span><span class="nx">length</span><span class="o">+</span><span class="mi">6</span><span class="p">);</span>
  <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x78</span><span class="p">;</span>
  <span class="nx">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xDA</span><span class="p">;</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">deflated_data</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="k">new</span> <span class="nx">Int32Array</span><span class="p">([</span><span class="nx">calculated_checksum</span><span class="p">]).</span><span class="nx">buffer</span><span class="p">),</span> <span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">Uncompress</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="s2">&quot;DataError: Not enough input&quot;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">checksum</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Int32Array</span><span class="p">(</span><span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">subarray</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">)).</span><span class="nx">buffer</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
  <span class="kd">var</span> <span class="nx">inflated_data</span> <span class="o">=</span> <span class="nx">Inflate</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">subarray</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="o">-</span><span class="mi">4</span><span class="p">));</span>
  <span class="kd">var</span> <span class="nx">calculated_checksum</span> <span class="o">=</span> <span class="nx">adler32</span><span class="p">(</span><span class="nx">inflated_data</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span> <span class="o">&gt;</span> <span class="mi">6</span> <span class="o">&amp;&amp;</span> <span class="nx">inflated_data</span><span class="p">.</span><span class="nx">byteLength</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="s2">&quot;DataError: Unable to inflate the data&quot;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">checksum</span> <span class="o">!==</span> <span class="nx">calculated_checksum</span><span class="p">)</span> <span class="p">{</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>throw "DataError: Checksum don't match";</p></div></div><div class="code"><div class="wrapper">  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">inflated_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">return</span> <span class="p">{</span>
  <span class="s1">&#39;deflate&#39;</span><span class="o">:</span> <span class="nx">Deflate</span><span class="p">,</span>
  <span class="s1">&#39;inflate&#39;</span><span class="o">:</span> <span class="nx">Inflate</span><span class="p">,</span>
  <span class="s1">&#39;compress&#39;</span><span class="o">:</span> <span class="nx">Compress</span><span class="p">,</span>
  <span class="s1">&#39;uncompress&#39;</span><span class="o">:</span> <span class="nx">Uncompress</span>
<span class="p">};</span>

<span class="p">})();</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Create a simple buffer</p></div></div><div class="code"><div class="wrapper"><span class="cm">/*</span>
<span class="cm">var msg = &quot;Hello, ZLIB!&quot;;</span>
<span class="cm">var data = new ArrayBuffer(msg.length);</span>
<span class="cm">var i;</span>
<span class="cm">var uint8buf = new Uint8Array(data);</span>
<span class="cm">for(i=0; i &lt; msg.length; i+=1) {</span>
<span class="cm">  uint8buf[i] = msg.charCodeAt(i) &amp; 0xFF;</span>
<span class="cm">}</span>

<span class="cm">data = Zlib.compress(new Uint8Array(data), 9);</span>
<span class="cm">msg = [];</span>
<span class="cm">for(i=0; i &lt; data.length; i+=1) {</span>
<span class="cm">  msg.push(String.fromCharCode(data[i]));</span>
<span class="cm">}</span>
<span class="cm">console.log(msg);</span>

<span class="cm">data = Zlib.deflate(new Uint8Array(data), 9);</span>
<span class="cm">data = Zlib.inflate(new Uint8Array(data));</span>

<span class="cm">*/</span>

<span class="nx">exports</span><span class="p">.</span><span class="nx">inflate</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">uint8buf</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">+=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">uint8buf</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">data</span> <span class="o">=</span> <span class="nx">Zlib</span><span class="p">.</span><span class="nx">inflate</span><span class="p">(</span><span class="nx">uint8buf</span><span class="p">);</span>
  <span class="nx">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">+=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">msg</span> <span class="o">+=</span> <span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">msg</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">exports</span><span class="p">.</span><span class="nx">uncompress</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">i</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">uint8buf</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">+=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">uint8buf</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">data</span> <span class="o">=</span> <span class="nx">Zlib</span><span class="p">.</span><span class="nx">uncompress</span><span class="p">(</span><span class="nx">uint8buf</span><span class="p">);</span>
  <span class="nx">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">+=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">msg</span> <span class="o">+=</span> <span class="nb">String</span><span class="p">.</span><span class="nx">fromCharCode</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">msg</span><span class="p">;</span>
<span class="p">}</span></div></div></div></div></body></html>